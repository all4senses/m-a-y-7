<?php

/**
 * @file 2
 * Module for Instagram API
 */

/**
 * Implements hook_menu().
 */
function a4s_instagram_menu() {
  $items = array();
  
  $items['insta'] = array(
    'title' => t('Instagram API'),
    'page callback' => 'a4s_instagram_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  $items['insta_behat'] = array(
    'title' => t('Instagram Behat endpoint'),
    'page callback' => 'a4s_instagram_behat',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  $items['insta-get-images'] = array(
    'page callback' => 'a4s_insta_get_images_to_click_byTags_allUsers_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  $items['insta-update-followers'] = array(
    'page callback' => 'a4s_instagram_update_followers_all_users_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  $items['insta-update-activity'] = array(
    'page callback' => 'a4s_instagram_update_activity_all_users_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  $items['insta/activity-backlikes-prepare'] = array(
    'title' => '',
    'page callback' => 'a4s_instagram_get_newLikersAndFollowers_mediasToBackLike_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  

  $items['insta'] = array(
    'title' => t('Instagram'),
    'page callback' => 'a4s_instagram_stub_page',
    'access callback' => 'user_is_logged_in',
    'menu_name' => 'main-menu',
    'type' => MENU_NORMAL_ITEM,
  );
    
    $all_accounts = a4s_instagram_get_accounts_to_process();

    $items['insta/likes'] = array(
      'title' => t('Likes'),
      'page callback' => 'a4s_instagram_stub_page',
      'access callback' => 'user_is_logged_in',
      'menu_name' => 'main-menu',
      'type' => MENU_NORMAL_ITEM,
    );
  
        foreach ($all_accounts as $account) {
          $items["insta/likes/$account"] = array(
            'title' => $account, //t('Instagram Likes'),
            'page callback' => 'a4s_instagram_likes_history_page',
            //'access arguments' => array('access content'),
            'access callback' => 'user_is_logged_in',
            'menu_name' => 'main-menu',
            'type' => MENU_NORMAL_ITEM,
          );
        }
  
     $items['insta/followers'] = array(
      'title' => t('Followers'),
      'page callback' => 'a4s_instagram_stub_page',
      'access callback' => 'user_is_logged_in',
      'menu_name' => 'main-menu',
      'type' => MENU_NORMAL_ITEM,
    ); 
        foreach ($all_accounts as $account) {
          $items["insta/followers/$account"] = array(
            'title' => $account,
            'page callback' => 'a4s_instagram_followers_history_page',
            //'access arguments' => array('access content'),
            'access callback' => 'user_is_logged_in',
            'menu_name' => 'main-menu',
            'type' => MENU_NORMAL_ITEM,
          );
        }

    $items['insta/activity'] = array(
      'title' => t('Activity'),
      'page callback' => 'a4s_instagram_stub_page',
      'access callback' => 'user_is_logged_in',
      'menu_name' => 'main-menu',
      'type' => MENU_NORMAL_ITEM,
    ); 
        foreach ($all_accounts as $account) {
          $items["insta/activity/$account"] = array(
            'title' => $account,
            'page callback' => 'a4s_instagram_activity_history_page',
            //'access arguments' => array('access content'),
            'access callback' => 'user_is_logged_in',
            'menu_name' => 'main-menu',
            'type' => MENU_NORMAL_ITEM,
          );
        }    
        
        
    $items['insta/auto-follow'] = array(
      'title' => t('Auto-following'),
      'page callback' => 'a4s_instagram_stub_page',
      'access callback' => 'user_is_logged_in',
      'menu_name' => 'main-menu',
      'type' => MENU_NORMAL_ITEM,
    ); 
        foreach ($all_accounts as $account) {
          $items["insta/auto-follow/$account"] = array(
            'title' => $account,
            'page callback' => 'a4s_instagram_autoFollowing_history_page',
            //'access arguments' => array('access content'),
            'access callback' => 'user_is_logged_in',
            'menu_name' => 'main-menu',
            'type' => MENU_NORMAL_ITEM,
          );
        }        
  
  $items['settings'] = array(
    'title' => t('Settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('a4s_instagram_settings'),
    //'access callback' => 'crc_portal_access_check',
    'access arguments' => array('administer site configuration'),
    //'menu_name' => 'user-menu',
    //'type' => MENU_NORMAL_ITEM,
    'menu_name' => 'main-menu',
    'type' => MENU_NORMAL_ITEM,
  );
  
  $items['insta-get-remote-user-followers'] = array(
    'page callback' => 'a4s_insta_get_remoteUsers_followers_callback',
    'page arguments' => array('1', '40'),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * 
 * @return string
 */
function a4s_instagram_stub_page() {
  return '';
}

/**
 * The main a4s Settings page at /settings
 * 
 * @param type $form
 * @param type $form_state
 * @return type
 */
function a4s_instagram_settings($form, $form_state) {
  
  $form['insta_settings'] = array(
    '#type' => 'fieldset',
    '#title' => 'Insta settings',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#access' => user_access('administer site configuration')
  );
  
    $form['insta_settings']['a4s_insta_accounts'] = array(
      '#type' => 'textfield',
      '#title' => 'All own accounts list, coma separated',
      '#default_value' => variable_get('a4s_insta_accounts', 'all4senses, olyayuskasova'),
    );
    
    $form['insta_settings']['a4s_insta_accounts_active'] = array(
      '#type' => 'textfield',
      '#title' => 'Active own accounts list (which are being processed currently), coma separated',
      '#default_value' => variable_get('a4s_insta_accounts_active', 'all4senses, olyayuskasova'),
    );
  
  
    $form['insta_settings']['a4s_insta_amount_of_medias_to_like_per_session'] = array(
      '#type' => 'textfield',
      '#title' => 'Amount of medias to like per each session (like every 10, 20,..., etc minutes)',
      '#default_value' => variable_get('a4s_insta_amount_of_medias_to_like_per_session', 7),
    );
    
    $form['insta_settings']['a4s_insta_history_period_hours_default'] = array(
      '#type' => 'textfield',
      '#title' => 'History, last hours to show',
      '#default_value' => variable_get('a4s_insta_history_period_hours_default', 12),
    );
    
    $form['insta_settings']['autofollowing'] = array(
      '#type' => 'fieldset',
      '#title' => 'Autofollowing',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
        $form['insta_settings']['autofollowing']['a4s_insta_auto_following_period_h'] = array(
          '#type' => 'textfield',
          '#title' => 'Auto Following period, hours',
          '#default_value' => variable_get('a4s_insta_auto_following_period_h', 2),
        );
        $form['insta_settings']['autofollowing']['a4s_insta_auto_unfollowing_period_h'] = array(
          '#type' => 'textfield',
          '#title' => 'Auto Unfollowing period, hours',
          '#default_value' => variable_get('a4s_insta_auto_unfollowing_period_h', 2),
        );
        $form['insta_settings']['autofollowing']['a4s_insta_autofollow_history_show_only_valid'] = array(
          '#type' => 'checkbox',
          '#title' => 'Auto follow history: show only success or not processed',
          '#default_value' => variable_get('a4s_insta_autofollow_history_show_only_valid', TRUE),
        );
    
      
        
        
    if(!$all_accounts = a4s_instagram_get_accounts_to_process('all')) {
      return;
    }
    $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
    
    $form['insta_settings']['settings_per_account'] = array(
      '#type' => 'fieldset',
      '#title' => 'Settings, per account',
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    
        foreach ($all_accounts as $account) {

          // TODO: Sanitize user name as it can contain dots (a4s.history), and variable_set cannot save variables with dots
          /*
          $account_original = $account;
          $account = a4s_insta_sanitize_account_name($account);
          */
          
          $form['insta_settings']['settings_per_account'][$account] = array(
            '#type' => 'fieldset',
            //'#title' => $account_original == $account_original ? $account_original : "$account_original [sanitized name: $account]",
            '#title' => $account,
            '#collapsible' => TRUE,
            '#collapsed' => FALSE,
          );
              
              $form['insta_settings']['settings_per_account'][$account]['creds'] = array(
                '#type' => 'fieldset',
                '#title' => "Creds",
                '#collapsible' => TRUE,
                '#collapsed' => TRUE,
              );
                  $form['insta_settings']['settings_per_account'][$account]['creds']['a4s_insta_account_pass__' . $account] = array( 
                    '#type' => 'textfield',
                    '#title' => "Pass",
                    '#default_value' => variable_get('a4s_insta_account_pass__' . $account, NULL),
                  );
                  $form['insta_settings']['settings_per_account'][$account]['creds']['a4s_insta_account_cookies__' . $account] = array( 
                    '#type' => 'textarea',
                    '#title' => "Current cookies (do not change!)",
                    '#default_value' => !empty($behat_insta_cookies['https://instagram.com'][$account]) ? print_r($behat_insta_cookies['https://instagram.com'][$account], TRUE) : NULL,
                  );
              
              
              
                  
              
              $form['insta_settings']['settings_per_account'][$account]['a4s_remote_accounts_to_get_folowers'] = array(
                '#type' => 'fieldset',
                '#title' => "Remote accounts to get folowers from",
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
              );
                  $form['insta_settings']['settings_per_account'][$account]['a4s_remote_accounts_to_get_folowers']['a4s_remote_accounts_to_get_folowers__' . $account] = array(
                    '#type' => 'textarea',
                    '#title' => "List of remote accounts (which you think has followers that you also need (and the same interests as you)",
                    '#default_value' => variable_get('a4s_remote_accounts_to_get_folowers__' . $account, NULL),
                  );
              
                  $form['insta_settings']['settings_per_account'][$account]['a4s_remote_accounts_to_get_folowers']['a4s_like_remote_accounts_followers__' . $account] = array(
                    '#type' => 'checkbox',
                    '#title' => "Like remote accounts (above) followers (before medias found by tags)",
                    '#default_value' => variable_get('a4s_like_remote_accounts_followers__' . $account, NULL),
                  );
              
              
              $form['insta_settings']['settings_per_account'][$account]['a4s_insta_account_tags__' . $account] = array(
                '#type' => 'textarea',
                '#title' => "Find users by Tags to like",
                '#default_value' => variable_get('a4s_insta_account_tags__' . $account, NULL),
              );

              $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like'] = array(
                '#type' => 'fieldset',
                '#title' => "Media likes conditions",
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
              );

                  $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like']['a4s_insta_account_like_condition_[likes]__' . $account] = array(
                    '#type' => 'textfield',
                    '#title' => "Media likes (from, to)",
                    '#default_value' => variable_get('a4s_insta_account_like_condition_[likes]__' . $account, '0, 200'),
                  );
                  $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like']['a4s_insta_account_like_condition_[posts]__' . $account] = array(
                    '#type' => 'textfield',
                    '#title' => "User posts (from, to)",
                    '#default_value' => variable_get('a4s_insta_account_like_condition_[posts]__' . $account, '1, 500'),
                  );
                  $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like']['a4s_insta_account_like_condition_[followers]__' . $account] = array(
                    '#type' => 'textfield',
                    '#title' => "User followers (from, to)",
                    '#default_value' => variable_get('a4s_insta_account_like_condition_[followers]__' . $account, '1, 2000'),
                  );
                  $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like']['a4s_insta_account_like_condition_[following]__' . $account] = array(
                    '#type' => 'textfield',
                    '#title' => "User following (from, to)",
                    '#default_value' => variable_get('a4s_insta_account_like_condition_[following]__' . $account, '20, 800'),
                  );
                  $form['insta_settings']['settings_per_account'][$account]['accounts_conditions_to_like']['a4s_insta_account_like_condition_[username_does_not_contain]__' . $account] = array(
                    '#type' => 'textfield',
                    '#title' => "Username does not contain substrings (coma separated)",
                    '#default_value' => variable_get('a4s_insta_account_like_condition_[username_does_not_contain]__' . $account, 'vulkan, casino'),
                  );

              
              $form['insta_settings']['settings_per_account'][$account]['a4s_insta_account_allow_to_autofollow__' . $account] = array(
                '#type' => 'checkbox',
                '#title' => "Autofollow is ON",
                '#default_value' => variable_get('a4s_insta_account_allow_to_autofollow__' . $account, NULL),
              );

        }
          
    
  return system_settings_form($form);
}

/**
 * Make some changes to DB while saving a site settings
 * 
 * @param type $form
 * @param type $form_state
 */
function a4s_instagram_settings_validate($form, $form_state) {
  
  // If a list of own accounts has been changed, let's add new users data to DB
  if ($form_state['values']['a4s_insta_accounts'] != $form_state['complete form']['insta_settings']['a4s_insta_accounts']['#default_value']) {
    $accounts = explode(',', $form_state['values']['a4s_insta_accounts']);
    foreach ($accounts as $own_account) {
      if(!$own_account = trim($own_account)) {
        continue;
      }
      $own_account_data = db_select('a4s_insta_own_users', 'u')
        ->fields('u', array('uid'))
        ->condition('u.username', $own_account)
        ->execute()->fetchObject();
      
      if (!$own_account_data) {
        $own_account_profile = a4s_insta_get_userProfile($own_account);
        if (empty($own_account_profile['id'])) {
          drupal_set_message("Error has occured while fetching a profile data saving for an Own account [$own_account] from Instagram", 'error');
          continue;
        }
        $own_account_data = array(
          'remote_id' => $own_account_profile['id'],
          'username' => $own_account,
          'fullname' => utf8_encode($own_account_profile['full_name']),
          'thumbnail' => $own_account_profile['profile_pic_url'],
          'followed_by_amount' => $own_account_profile['edge_followed_by']['count'],
          'following_amount' => $own_account_profile['edge_follow']['count'],
          'posts_amount' => $own_account_profile['edge_owner_to_timeline_media']['count'],
          'active' => 1,
          'extra_data' => NULL, 
          'timestamp_created' => NULL, 
          'timestamp_added' => REQUEST_TIME, 
          'timestamp_updated' => REQUEST_TIME,
        );
        $uid = db_insert('a4s_insta_own_users')->fields($own_account_data)->execute();
        if ($uid) {
          drupal_set_message("A new Own account [$own_account] has been added to our DB with a local uid=$uid");
        }
        else {
          drupal_set_message("Error has occured while saving a new Own account [$own_account] to our DB", 'error');
        }
      }
    }
  }
  
  if ($form_state['values']['a4s_insta_accounts_active'] != $form_state['complete form']['insta_settings']['a4s_insta_accounts_active']['#default_value']) {
    $own_accounts_active = explode(',', $form_state['values']['a4s_insta_accounts_active']);
    foreach ($own_accounts_active as $key => &$own_account_active) {
      if(!$own_account_active = trim($own_account_active)) {
        unset($own_accounts_active[$key]);
      }
    }
    // Get all own accounts from DB
    $own_accounts = db_select('a4s_insta_own_users', 'u')
        ->fields('u', array('uid', 'username', 'active'))
        ->execute()->fetchAllAssoc('username');
    foreach ($own_accounts as $own_account_username => $own_account) {
      if (!in_array($own_account_username, $own_accounts_active)) {
        if ($own_account->active) {
          // Update DB to set active = 0
          db_update('a4s_insta_own_users')
            ->fields(array('active' => 0))
            ->condition('uid', $own_account->uid)
            ->execute();
          drupal_set_message("Changed an Own account [$own_account_username] status to Inactive in our DB");
        }
      }
      elseif (!$own_account->active) {
        // Update DB to set active = 1
        db_update('a4s_insta_own_users')
            ->fields(array('active' => 1))
            ->condition('uid', $own_account->uid)
            ->execute();
        drupal_set_message("Changed an Own account [$own_account_username] status to Active in our DB");
      }
    }
    
  }
  
  
}

/**
 * 
 * @param type $account
 */
function a4s_insta_sanitize_account_name($account, $reverse = FALSE) {
  $output = $account;
  $mapping = array(
    'a4s.history' => 'a4s_history',
  );
  
  if ($reverse) {
    $account = array_search($account, $mapping);
  }
  else {
    $account = $mapping[$account];
  }
  return $account;
}
/**
 * 
 * @param type $account
 */
function a4s_instagram_is_account_allowed_to_autoFollow($account) {
  return variable_get('a4s_insta_account_allow_to_autofollow__' . $account, NULL);
}

/**
 * 
 * @param type $username
 * @return type
 */
function a4s_insta_get_account_conditions_to_like_medias($username = NULL) {
  /*
  $like_conditions_default = array('media' => array('likes' => array('from' => 0, 'to' => 200)), 
                                 'user' => array('posts' => array('from' => 1, 'to' => 500), 
                                                 'followers' => array('from' => 1, 'to' => 2000), 
                                                 'following' => array('from' => 20, 'to' => 800),
                                                 'username_does_not_contain' => array('vulkan', 'casino')
                                                )
                                );
  $like_conditions_default = variable_get('a4s_like_conditions', $like_conditions_default);
  */
  $accounts_to_process = a4s_instagram_get_accounts_to_process();
  if ($username && !in_array($username, $accounts_to_process)) {
    return NULL;
  }
  if ($username) {
    $accounts_to_process = array($username);
  }
  $all_conditions = array();
  foreach ($accounts_to_process as $account) {
    foreach (['likes' => 'media', 'posts' => 'user', 'followers' => 'user', 'following' => 'user', 'username_does_not_contain' => 'user'] as $type => $group) {
      $data = variable_get("a4s_insta_account_like_condition_[$type]__" . $account, NULL);
      if ($type == 'username_does_not_contain') {
        $all_conditions[$account][$group][$type] = explode(',', $data);
      }
      else {
        list($all_conditions[$account][$group][$type]['from'], $all_conditions[$account][$group][$type]['to']) = explode(',', $data);
      }
      foreach ($all_conditions[$account][$group][$type] as &$value) {
        $value = trim($value);
      }
    }
  }
  return $username? $all_conditions[$username] : $all_conditions;
}


/**
 * 
 * @param type $account
 */
function a4s_insta_get_user_tags($account = NULL) {
  
  $accounts_to_process = a4s_instagram_get_accounts_to_process();
  
  /*
  $insta_users_tags_default = array(
    'all4senses' => array('designer', 'art', 'graphicdesign', 'photographer', 'productdesign', 'architecture', 'arhitect', 'photoart', 'artwork', 'interiordesign', 'дизайнинтерьера', 'photoshoot', 'photosession', 'digitalart', '3dart'),
    'olyayuskasova' => array(
      'nsk', 'novosibirsk', 'новосибирск', 'нск', 'нск54', 'вьетнам', 'бизнес', 'тайланд', 'тай', 'толмачево', 'дом', 'nsk54', 'нижневартовск', 'норильск', 'якутск', 'магадан', 'сургут', 'мальдивы',
      ),
  );
  */
  $insta_users_tags_default = array(
    'all4senses' => NULL,// 'designer, art, graphicdesign, photographer, productdesign, architecture, arhitect, photoart, artwork, interiordesign, дизайнинтерьера, photoshoot, photosession, digitalart, 3dart',
    'olyayuskasova' => NULL, // 'nsk, novosibirsk, новосибирск, нск, нск54, вьетнам, бизнес, тайланд, тай, толмачево, дом, nsk54, нижневартовск, норильск, якутск, магадан, сургут, мальдивы',
  );
  
  if (!$account) {
    $all_tags = array();
    foreach ($accounts_to_process as $account) {
      $all_tags[$account] = variable_get('a4s_insta_account_tags__' . $account, $insta_users_tags_default[$account]);
      $all_tags[$account] = explode(',', $all_tags[$account]);
      foreach ($all_tags[$account] as &$tag) {
        $tag = trim($tag);
      }
    }
    return $all_tags;
  }
  
  $tags = variable_get('a4s_insta_account_tags__' . $account, $insta_users_tags_default[$account]);
  $tags = explode(',', $tags);
  foreach ($tags as &$tag) {
    $tag = trim($tag);
  }
  return $tags;
}

/**
 * 
 * @param type $status
 * @return array
 */
function a4s_instagram_get_accounts_to_process($status = 'active') {
  
  $query = db_select('a4s_insta_own_users', 'u')
      ->fields('u', array('username'));
  if ($status == 'active') {
    $query->condition('active', 1);
  }
  if(!$accounts = $query->execute()->fetchCol()) {
    $accounts = array();
  }
  return $accounts;
    
  /*
  switch ($status) {
    case 'all':
      $variable_name = 'a4s_insta_accounts';
      break;
    
    case 'active':
      $variable_name = 'a4s_insta_accounts_active';
      break;
  }
  
  if($accounts_to_process = variable_get($variable_name, 'all4senses, olyayuskasova')) {
    $accounts_to_process = explode(',', $accounts_to_process);
    foreach ($accounts_to_process as &$account_to_process) {
      $account_to_process = trim($account_to_process);
    }
  }
  else {
    $accounts_to_process = array();
  }
  return $accounts_to_process;
  */
}

/**
 * 
 * @param type $domain
 * @param type $account
 * @return type
 */
function a4s_instagram_get_accounts_credentials($domain, $account = NULL) {
  if ($domain != 'https://instagram.com') {
    return NULL;
  }
  $all_accounts = a4s_instagram_get_accounts_to_process('all');
  if(!$all_accounts || ($account && !in_array($account, $all_accounts))) {
    return NULL;
  }
  if (!$account) {
    $all_creds = array();
    foreach ($all_accounts as $account) {
      $all_creds[$account] = variable_get('a4s_insta_account_pass__' . $account, NULL);
    }
    return $all_creds;
  }
  return variable_get('a4s_insta_account_pass__' . $account, NULL);
}
        
/**
 * 
 */
function a4s_instagram_behat() {
  
  /*
  $url = '';
  $ch = curl_init($url);
  curl_setopt($ch, CURLOPT_POST, TRUE);
  curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  //curl_setopt($ch, CURLOPT_USERPWD, $username . ":" . $password);
  $results = json_decode(curl_exec($ch), TRUE);
  curl_close($ch);
  */
  $status = TRUE;
  $errors = NULL;
  $cookies = NULL;
  $response_data = array();
  if (!empty($_REQUEST['op'])) {
    switch ($_REQUEST['op']) {
      case 'set_cookies':
        if (empty($_REQUEST['target_domain']) || empty($_REQUEST['cookies'])|| empty($_REQUEST['username'])) {
          $status = FALSE;
          $errors = 'Wrong source parameters';
          break;
        }
        else {
          $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
          $new_cookies = unserialize($_REQUEST['cookies']);
          $behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['cookies'] = $new_cookies;
          foreach ($new_cookies as $new_cookie) {
            switch ($new_cookie['name']) {
              case 'ds_user_id':
                //4016509096; // solo, 6218303298; // a4s
                $behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['ds_user_id'] = $new_cookie['value'];
                break;
              case 'csrftoken':
                $behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['csrftoken'] = $new_cookie['value'];
                break;
              case 'sessionid':
                $behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['sessionid'] = $new_cookie['value'];
                break;
            }
          }
          if (!empty($behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['sessionid'])) {
            variable_set('a4s_behat_insta_cookies', $behat_insta_cookies);
          }
          else {
            $status = FALSE;
            $errors = 'Something wrong with Instagram cookies: sessionid is empty.';
          }
        }
        break;
        
      case 'get_cookies':
        if (empty($_REQUEST['target_domain']) || empty($_REQUEST['username'])) {
          $status = FALSE;
          $errors = 'Wrong source parameters';
          break;
        }
        else {
          $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
          if (!empty($behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['cookies'])) {
            $cookies = $behat_insta_cookies[$_REQUEST['target_domain']][$_REQUEST['username']]['cookies'];
            $response_data['cookies'] = $cookies;
          }
        }
        break;
        
      case 'get_creds':
        if (empty($_REQUEST['target_domain'])/* || empty($_REQUEST['username'])*/) {
          $status = FALSE;
          $errors = 'Wrong source parameters';
          break;
        }

        // Send different user creds every time
        //$users_to_process = array('olyayuskasova', 'all4senses');
        $accounts_to_process = a4s_instagram_get_accounts_to_process();
        
        $insta_last_data_processed = variable_get('a4s_insta_last_data_sent', array());
        
        if (count($accounts_to_process) > 1) {
          if (empty($insta_last_data_processed['username'])) {
            $current_user = $accounts_to_process[0];
          }
          else {
            foreach ($accounts_to_process as $key => $user) {
              if ($user == $insta_last_data_processed['username']) {
                if ($key + 1 >= count($accounts_to_process)) {
                  $current_user = $accounts_to_process[0];
                }
                else {
                  $current_user = $accounts_to_process[$key + 1];
                }
              }
            }
          }
        }
        else {
          $current_user = $accounts_to_process[0];
        }
        
        $insta_last_data_processed['username'] = $current_user;
        variable_set('a4s_insta_last_data_sent', $insta_last_data_processed);
        
        //$users_credentials = variable_get('a4s_users_credentials', array());
        //if ( empty($users_credentials[$_REQUEST['target_domain']][$current_user]) ) {
        if (!$curent_user_pass = a4s_instagram_get_accounts_credentials($_REQUEST['target_domain'], $current_user)) {
          $status = FALSE;
          $errors = 'We do not have credentials for ' . $current_user;
          break;
        }
        
        $response_data['creds'] = a4s_insta_user_credentials_environment($_REQUEST['target_domain'], $current_user);
        //$response_data['creds']['p'] = $users_credentials[$_REQUEST['target_domain']][$current_user];
        $response_data['creds']['p'] = $curent_user_pass;
        
        $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
        if (!empty($behat_insta_cookies[$_REQUEST['target_domain']][$current_user]['cookies'])) {
          $cookies = $behat_insta_cookies[$_REQUEST['target_domain']][$current_user]['cookies'];
          $response_data['cookies'] = $cookies;
        }
        break;
        
        
        
        
      case 'alert':
        $alert_count_to_disable_behat = variable_get('a4s_max_fails_before_behat_disable', 7);
        $subject = 'Alert from Behat!';
        $a4s_behat_alerts_count = variable_get('a4s_behat_alerts_count', 0) + 1;
        watchdog('Probems with Behat, Alert', "Problems from Behat (#$a4s_behat_alerts_count):  " . $_REQUEST['message'] . ' ==> <pre>'. print_r($_REQUEST['data'], TRUE) . '</pre>');
        if ($a4s_behat_alerts_count >= $alert_count_to_disable_behat) {
          a4s_instagram_jenkins_insta_switch_status('disable');
          $a4s_behat_alerts_count = 0;
          //drupal_mail('a4s_instagram', 'behat_problems_alert', 'all4senses@gmail.com', LANGUAGE_NONE, array('subject' => $subject, 'message' => $_REQUEST['message'], 'data' => $_REQUEST['data']));
          watchdog('Probems with Behat, OFF', "Behat is TURNED OFF, because of $alert_count_to_disable_behat alerts of problems");
        }
        variable_set('a4s_behat_alerts_count', $a4s_behat_alerts_count);
        break;
      
      
      
      
      case 'get_medias_to_like':
        
        //watchdog('Request media from handler', '$_REQUEST ==> <pre>'. print_r($_REQUEST, TRUE) . '</pre>');
        
        if (empty($_REQUEST['username'])) {
          $status = FALSE;
          $errors = 'No username provided';
          break;
        }

        $current_user = $_REQUEST['username'];
        
        if ($back_likes_planned_amount = a4s_insta_get_medias_to_like($current_user, $tag = 'back-like', $amount = NULL, $return_type = 'amount')) {
          $current_tag = 'back-like';
          $response_data['force_like'] = TRUE;
        }
        elseif ($back_likes_planned_amount = a4s_insta_get_medias_to_like($current_user, $tag = 'unfollow-like', $amount = NULL, $return_type = 'amount')) {
          $current_tag = 'unfollow-like';
        }
        else {
              // Define a current tag to like
          
              $insta_current_user_tags = a4s_insta_get_user_tags($current_user);
              $insta_last_data_processed = variable_get('a4s_insta_last_data_sent', array());
              //watchdog('Request media from handler', '$insta_last_data_processed ==> <pre>'. print_r($insta_last_data_processed, TRUE) . '</pre>');

              if (count($insta_current_user_tags) > 1) {
                if (empty($insta_last_data_processed['tag'][$current_user]) || !in_array($insta_last_data_processed['tag'][$current_user], $insta_current_user_tags)) {
                  $current_tag = $insta_current_user_tags[0];
                }
                else {
                  foreach ($insta_current_user_tags as $key => $tag) {
                    if ($tag == $insta_last_data_processed['tag'][$current_user]) {
                      if ($key + 1 >= count($insta_current_user_tags)) {
                        $current_tag = $insta_current_user_tags[0];
                      }
                      else {
                        $current_tag = $insta_current_user_tags[$key + 1];
                      }
                    }
                  }
                }
              }
              else {
                $current_tag = $insta_current_user_tags[0];
              }
              $insta_last_data_processed['tag'][$current_user] = $current_tag;

              variable_set('a4s_insta_last_data_sent', $insta_last_data_processed);
        }
        
        $amount = variable_get('a4s_insta_amount_of_medias_to_like_per_session', 7);
        $response_data['medias'] = a4s_insta_get_medias_to_like($current_user, $current_tag, $amount, $return_type = 'data');
        $response_data['tag'] = $current_tag;
        break;
        
        
        
        
      case 'set_medias_like_results':
        $links = array();
        if (!empty($_REQUEST['medias'])) {
          foreach (json_decode($_REQUEST['medias'], TRUE) as $media => $data) {
            $links[] = l($media, 'https://instagram.com/p/' . $media, array('attributes' => array('absolute' => TRUE)));
          }
        }
        watchdog('Liked with Behat', 'Tag ' . @$_REQUEST['tag'] . ' for ' . $_REQUEST['username'] . ' ==> <pre>'. print_r(@$_REQUEST['medias'], TRUE) . '</pre>, links ===> <pre>' . print_r($links, TRUE) . '</pre>');
        if (empty($_REQUEST['medias']) || empty($_REQUEST['username'])) {
          $status = FALSE;
          $errors = 'No username provided OR Empty liked medias results from behat.';
          break;
        }
        variable_set('a4s_behat_alerts_count', 0);
        foreach (json_decode($_REQUEST['medias'], TRUE) as $shortcode => $data) {
          a4s_insta_media_set_liked($_REQUEST['username'], $shortcode, $data);
        }
        break;
    }
  }
  if (!$status) {
    // Report only in case of problems.
    watchdog('Request from Behat', "Error: $errors, _REQUEST ==> <pre>" . print_r($_REQUEST, TRUE) . '</pre>, $_SERVER ==> <pre>' . print_r($_SERVER, TRUE) . '</pre>');
  }
  $response_data += array('status' => $status, 'errors' => $errors);
  echo json_encode($response_data);
}

/**
 * 
 * @param type $domain
 * @param type $username
 * @return type
 */
function a4s_insta_user_credentials_environment($domain, $username = NULL) {
  $users_credentials_environment_default = array(
    'https://instagram.com' => array(
      'all4senses' => array(
        'u' => 'all4senses', 'p' => NULL,
        'u_field' => 'Phone number, username, or email',
        'p_field' => 'Password',
        'login_button' => 'Log in',
        'login_confirm_text' => array('All4senses Creative Group', 'Turn On Notifications'),
        'turn_on_notifications_button' => 'Turn On',
       ),
      'olyayuskasova' => array(
        'u' => 'olyayuskasova', 'p' => NULL,
        'u_field' => 'Phone number, username, or email',
        'p_field' => 'Password',
        'login_button' => 'Log in',
        'login_confirm_text' => array('Olga Yuskasova', 'Turn On Notifications'),
        'turn_on_notifications_button' => 'Turn On',
       ),
    ),
  );
  $users_credentials_environment = variable_get('a4s_users_credentials_environment', $users_credentials_environment_default);

  /*
  $like_conditions_default = array('media' => array('likes' => array('from' => 0, 'to' => 200)), 
                                   'user' => array('posts' => array('from' => 1, 'to' => 500), 
                                                   'followers' => array('from' => 1, 'to' => 2000), 
                                                   'following' => array('from' => 20, 'to' => 800),
                                                   'username_does_not_contain' => array('vulkan', 'casino')
                                                  )
                                  );
  
  
  $like_conditions_default = variable_get('a4s_like_conditions', $like_conditions_default);
  
  foreach ($users_credentials_environment['https://instagram.com'] as &$data) {
    if (empty($data['like_conditions'])) {
      $data['like_conditions'] = $like_conditions_default;
    }
  }
  */
  if ($domain && $username) {
    $users_credentials_environment[$domain][$username]['like_conditions'] = a4s_insta_get_account_conditions_to_like_medias($username);
    return $users_credentials_environment[$domain][$username];
  }

  $all_like_conditions = a4s_insta_get_account_conditions_to_like_medias();
  foreach ($all_like_conditions as $username => $like_conditions) {
    $users_credentials_environment[$domain][$username]['like_conditions'] = $like_conditions;
  }
  return $users_credentials_environment[$domain];
}

/**
 * 
 * @return type
 */
function a4s_instagram_get_media_of_planned_to_autoUnfollow_user($account_id) {
  $media = NULL;
  $auto_unfollowing_period = variable_get('a4s_insta_auto_unfollowing_period_h', 2); // Hours
  if (!$auto_unfollowing_period) {
    // Unfollowing is turned off.
    return NULL;
  }
  
  /*
  $local_media_cid = db_select('a4s_insta_auto_following', 'f')
                ->fields('f', array('local_media_cid'))
                ->condition('f.account_id', $account_id)
                ->isNull('f.timestamp_ended')
                ->isNotNull('f.timestamp_started')
                ->condition('f.timestamp_started', REQUEST_TIME - 60*60*$auto_unfollowing_period, '<')
                ->orderBy('f.timestamp_started', 'asc')
                ->execute()
                ->fetchField();
  
  if ($local_media_cid) {
    $query = db_select('a4s_insta_clicks_by_tag', 'l')
          ->fields('l', array('cid', 'shortcode', 'caption', 'media_owner_id'))
          ->condition('l.cid', $local_media_cid);

    $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = l.media_owner_id');
    $query->fields('e', array( 'followed_by_amount', 'following_amount', 'posts_amount')); // 'username' -> exclude to allow to refine the username, in case it has been changed
    $media = $query->execute()->fetchObject();
  }
  */
  
  $query = db_select('a4s_insta_auto_following', 'f')
              ->condition('f.account_id', $account_id)
              ->isNull('f.timestamp_ended')
              ->isNotNull('f.timestamp_started')
              ->condition('f.timestamp_started', REQUEST_TIME - 60*60*$auto_unfollowing_period, '<')
              ->orderBy('f.timestamp_started', 'asc');

  $query->leftJoin('a4s_insta_clicks_by_tag', 'm', 'm.cid = f.local_media_cid');
  $query->fields('m', array('cid', 'shortcode', 'caption', 'media_owner_id'));
  $query->isNotNull('m.shortcode');

  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = f.remote_id');
  $query->fields('e', array( 'followed_by_amount', 'following_amount', 'posts_amount')); // 'username' -> exclude to allow to refine the username, in case it has been changed
  $media = $query->execute()->fetchObject();
    
  return $media;
}

/**
 * 
 * @param type $username
 * @param type $tag
 * @param type $amount
 * @return type
 */
function a4s_insta_get_medias_to_like($username, $tag, $amount, $return_type = 'data'){
  
//  $map_username_to_account_id_default = array('all4senses' => 1, 'olyayuskasova' => 2);
//  $map_username_to_account_id = variable_get('a4s_map_username_to_account_id', $map_username_to_account_id_default);
//  $account_id = $map_username_to_account_id[$username];

  $account_id = a4s_instagram_get_local_account_id_by_username($username);
  
  //watchdog('Request media from handler', '$account_id = '. $account_id);
  switch ($return_type) {
    case 'data':
      
      $query = db_select('a4s_insta_clicks_by_tag', 'l')
            ->fields('l', array('cid', 'shortcode', 'caption', 'media_owner_id'))
            ->condition('l.tag', $tag)
            ->condition('l.account_id', $account_id)
            ->isNull('l.liked');

      $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = l.media_owner_id');
      $query->fields('e', array('username', 'followed_by_amount', 'following_amount', 'posts_amount'));
      $query->orderBy('l.timestamp_added')
            ->range(0, $amount);
      $not_liked_by_tag = $query->execute()->fetchAllAssoc('shortcode');

      if($media_of_planned_to_autoUnfollow_user = a4s_instagram_get_media_of_planned_to_autoUnfollow_user($account_id)) {
        $media_of_planned_to_autoUnfollow_user->op = 'unfollow';
        $not_liked_by_tag[$media_of_planned_to_autoUnfollow_user->shortcode] = $media_of_planned_to_autoUnfollow_user;
        watchdog('a4s insta auto-Unfollow', 'Planned to --Unfollow-- $account_id = ' . $account_id . ', media = ' . $media_of_planned_to_autoUnfollow_user->shortcode . ', owner = ' . $media_of_planned_to_autoUnfollow_user->media_owner_id);
        watchdog('a4s insta auto-Unfollow', 'Data prepared to --Unfollow-- <pre>' . print_r($media_of_planned_to_autoUnfollow_user, TRUE) . '</pre>' );
      }
      
      $already_auto_followed_someone_recently = TRUE;
      
      //$auto_following_allowed = variable_get('a4s_insta_auto_following', array(1 => TRUE, 2 => FALSE));
      //$auto_following_allowed_for_account = variable_get('a4s_insta_auto_following', array(1 => TRUE, 2 => FALSE));
      $auto_following_allowed_for_account = a4s_instagram_is_account_allowed_to_autoFollow($username);
      
      //if($tag != 'back-like' && $tag != 'unfollow-like' && $auto_following_allowed[$account_id]) {
      if($tag != 'back-like' && $tag != 'unfollow-like' && $auto_following_allowed_for_account) {
        if ($auto_following_period = variable_get('a4s_insta_auto_following_period_h', 3)) { // Hour(s)
          // We allow auto following ONLY if Following is NOT turned on, that is $auto_following_period != NULL.
          $already_auto_followed_someone_recently = db_select('a4s_insta_auto_following', 'f')
              ->fields('f', array('fid'))
              ->condition('f.account_id', $account_id)
              ->isNotNull('f.timestamp_started')
              ->condition('f.timestamp_started', REQUEST_TIME - 60*60*$auto_following_period, '>')
              ->orderBy('f.timestamp_started', 'desc')
              ->execute()
              ->fetchField();
        }
      }
      $auto_following_initiated = FALSE;
      foreach ($not_liked_by_tag as $key => $data) {
        
        if (!$auto_following_initiated && !$already_auto_followed_someone_recently) {
          // Check if it's already our follower OR it was our follower before
          $our_follower = db_select('a4s_insta_followers', 'f')
            ->fields('f', array('fid'))
            ->condition('f.account_id', $account_id)
            ->condition('f.remote_id', $data->media_owner_id)
            ->execute()
            ->fetchField();
          if (!$our_follower) {
            // Check if we already follow, planned to follow or followed before this user
            $we_following = db_select('a4s_insta_auto_following', 'f')
              ->fields('f', array('fid', 'timestamp_started', 'status'))
              ->condition('f.account_id', $account_id)
              ->condition('f.remote_id', $data->media_owner_id)
              ->execute()
              ->fetchObject();
            if (!empty($we_following) && empty($we_following->timestamp_started) && empty($we_following->status)) {
              watchdog('a4s insta auto-follow', '!!! Re-Planned to follow $account_id = ' . $account_id . ', media = ' . $data->shortcode . ', owner = ' . $data->media_owner_id);
              $data->op = 'like-and-follow';
              $auto_following_initiated = TRUE;
            }
            else {
              // Set the first media (its owner) to follow
              // if it's time to follow
              $fid = db_insert('a4s_insta_auto_following')->fields(
                array(
                  'remote_id' => $data->media_owner_id,
                  'account_id' => $account_id,
                  'local_media_cid' => $data->cid,
                  'timestamp_added' => REQUEST_TIME,
                )
               )->execute();
              if ($fid) {
                watchdog('a4s insta auto-follow', 'Planned to follow $account_id = ' . $account_id . ', media = ' . $data->shortcode . ', owner = ' . $data->media_owner_id);
                $data->op = 'like-and-follow';
                $auto_following_initiated = TRUE;
              }
            }
          }
        }
        unset($data->shortcode);
        $not_liked_by_tag[$key] = json_encode((array) $data);
      }

      return $not_liked_by_tag;
      
      
      
    case 'amount':
      
      $query = db_select('a4s_insta_clicks_by_tag', 'l')
            ->fields('l', array('shortcode', 'caption', 'media_owner_id'))
            ->condition('l.tag', $tag)
            ->condition('l.account_id', $account_id)
            ->isNull('l.liked');
      $not_liked_by_tag_amount = $query->countQuery()->execute()->fetchField();

      return $not_liked_by_tag_amount;
      
  }
  return NULL;
}

/**
 * 
 * @param type $username
 * @param type $shortcode
 * @param type $data
 */
function a4s_insta_media_set_liked($username, $shortcode, $data) {
  
  //watchdog('Liked with Behat', 'Tag ' . @$_REQUEST['tag'] . ', data ==> <pre>'. print_r($data, TRUE) . '</pre>');
  
  $account_id = a4s_instagram_get_local_account_id_by_username($username);
  
  if (!empty($data['auto_unfollowing_status'])) {
    $status_int = a4s_instagram_autoFollowing_statusMapping($data['auto_unfollowing_status']);
    $fields_to_update = array('status' => $status_int);
    if ($status_int === 1 || $status_int == 7) { // Successfully unfollowed or was already undollowed before this
      $fields_to_update['timestamp_ended'] = REQUEST_TIME;
    }
    db_update('a4s_insta_auto_following')
      ->fields($fields_to_update)
      ->condition('remote_id', $data['owner']['remote_id'])
      ->condition('account_id', $account_id)
      ->execute();
    watchdog('a4s insta auto-Unfollow', 'Results: status = ' . $data['auto_unfollowing_status'] . ', media = ' . $shortcode . ', owner = ' . $data['owner']['remote_id'] . ', $account_id = ' . $account_id);
    return;
  }
  
  
  if (strpos($data['liked'], 'disallowed_') !== FALSE) {
    db_delete('a4s_insta_clicks_by_tag')
      ->condition('shortcode', $shortcode)
      ->condition('account_id', $account_id)
      ->execute();
    
    $nid = db_insert('a4s_insta_do_not_like_medias')->fields(
        array(
          'shortcode' => $shortcode,
          'account_id' => $account_id,
          'timestamp' => REQUEST_TIME,
        )
       )->execute();
    
    //watchdog('Request from Behat, Warning', "Not found: media $shortcode for $username, and have been removed from likes DB table! _REQUEST ==> <pre>" . print_r($_REQUEST, TRUE) . '</pre>');
  }
  if ($data['liked'] == 'false') {
    db_update('a4s_insta_clicks_by_tag')
      ->fields(array('liked' => 2)) // 2 = Not liked, but kind of marked as processed
      ->condition('shortcode', $shortcode)
      ->condition('account_id', $account_id)
      ->execute();
    watchdog('Request from Behat, Warning', "Not liked for unknown reason: media $shortcode for $username, _REQUEST ==> <pre>" . print_r($_REQUEST, TRUE) . '</pre>');
  }
  elseif ($data['liked'] === 'true' || $data['liked'] === 'liked_before') {
    db_update('a4s_insta_clicks_by_tag')
      ->fields(array('liked' => 1, 'timestamp_liked' => time()))
      ->condition('shortcode', $shortcode)
      ->condition('account_id', $account_id)
      ->execute();
  }
  
  // Update a media owner data
  if (!empty($data['owner']['username']) || !empty($data['owner']['followed_by_amount']) || !empty($data['owner']['following_amount']) || !empty($data['owner']['posts_amount']) ) {
    //$data['owner']['remote_id']
    $extra_data_exists = db_select('a4s_insta_users_extra_data', 'e')
        ->fields('e', array('eid'))
        ->condition('e.remote_id', $data['owner']['remote_id'])
        ->execute()->fetchField();
    if ($extra_data_exists) {
      // Update
      db_update('a4s_insta_users_extra_data')
        ->fields(array(
            'username' => $data['owner']['username'], 
            'followed_by_amount' => $data['owner']['followed_by_amount'],
            'following_amount' => $data['owner']['following_amount'],
            'posts_amount' => $data['owner']['posts_amount'],
          ))
        ->condition('remote_id', $data['owner']['remote_id'])
        ->execute();
    }
    else {
      // Insert
      $eid = db_insert('a4s_insta_users_extra_data')->fields(
          array(
            'remote_id' => $data['owner']['remote_id'], 
            'username' => $data['owner']['username'], 
            'followed_by_amount' => $data['owner']['followed_by_amount'],
            'following_amount' => $data['owner']['following_amount'],
            'posts_amount' => $data['owner']['posts_amount'],
            'timestamp_added' => REQUEST_TIME,
          )
         )->execute();
    }
  }
  
  // Set auto following results
  if (!empty($data['auto_following_status'])) {
    $status_int = a4s_instagram_autoFollowing_statusMapping($data['auto_following_status']);
    $fields_to_update = array('status' => $status_int);
    if ($status_int === 1) {
      $fields_to_update['timestamp_started'] = REQUEST_TIME;
    }
    db_update('a4s_insta_auto_following')
      ->fields($fields_to_update)
      ->condition('remote_id', $data['owner']['remote_id'])
      ->condition('account_id', $account_id)
      ->execute();
    watchdog('a4s insta auto-follow', 'Results: status = ' . $data['auto_following_status'] . ', media = ' . $shortcode . ', owner = ' . $data['owner']['remote_id'] . ', $account_id = ' . $account_id);
  }
  
  
}

/**
 * 
 * @param type $status_str
 * @param type $status_int
 */
function a4s_instagram_autoFollowing_statusMapping($status_str, $status_int = NULL) {
  $status_mapping = array('ok' => 1, 
                          'Already following' => 2, 
                          'Not found either Follow or Following button' => 3, 
                          'Not found Following button after clicking on Follow button' => 4,
                          'Disabled statistics' => 5,
                          'Not found Follow button after clicking on Following button' => 6,
                          'Already unfollowed' => 7, 
                         );
  if ($status_str) {
    return !empty($status_mapping[$status_str]) ? $status_mapping[$status_str] : NULL;
  }
  elseif ($status_int) {
    return array_search($status_int, $status_mapping);
  }
  return NULL;
}

/**
 * Implements hook_mail().
 */
function a4s_instagram_mail($key, &$message, $params) {
  switch ($key) {
    
    case 'behat_problems_alert':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['message'] . '
        

<pre>' . print_r($params['data'], TRUE) . '</pre>';
      break;

  }
}

/**
 * 
 * @return string
 */
function  a4s_instagram_page() {
  
  $instagram_accounts_granted = variable_get('instagram_accounts_granted', NULL);
  if (!empty($instagram_accounts_granted) && !empty($instagram_accounts_granted['all4senses'])) {
    dpm($instagram_accounts_granted, '$instagram_accounts_granted');
    dpm('We have access. Let\'s Rock!');
   
    return 'Processed a real request to Instagram...';
  }
  
  dpm($_REQUEST, '$_REQUEST');
  $CLIENT_ID = '1eca294b0a6b478b9de165d9384edac1';
  $REDIRECT_URI = 'http://m-a-y.ru/insta';
  $CLIENT_SECRET = '59007de215f4492fb4cdca497e3b943a';
  
  if (!empty($_REQUEST['code'])) {
    $url = 'https://api.instagram.com/oauth/access_token';

    $data = array(
      'client_id' => $CLIENT_ID,
      'client_secret' => $CLIENT_SECRET,
      'grant_type' => 'authorization_code',
      'redirect_uri' => $REDIRECT_URI,
      'code'=> $_REQUEST['code'],
    ); 

    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_POST, count($data));
    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

    $results = json_decode(curl_exec($ch), TRUE);
    curl_close($ch);
    dpm($results, '$results');
    if (!empty($results['access_token'])) {
      $instagram_accounts_granted[$results['user']['username']] = $results;
      variable_set('instagram_accounts_granted', $instagram_accounts_granted);
    }
    $out = 'We have got an access_token...';
    drupal_goto($REDIRECT_URI);
  }
  else {
     
    $out = '<a href="https://api.instagram.com/oauth/authorize/?client_id=' . $CLIENT_ID. '&redirect_uri=' . $REDIRECT_URI . '&response_type=code" >Authorize with Instagram</a>';
  }
  return $out;
}

/**
 * 
 * @param type $data_type
 * @param type $username
 * @param type $pages_count
 * @param type $end_cursor
 * @param type $items_per_query
 * @return type
 */
function a4s_insta_queryGraphql_multiple($data_type, $username, $pages_count = NULL, &$end_cursor = NULL, $items_per_query = 10, $ds_user_id = NULL) {
  $data = array();
  $data_all = array();
  $max_id = NULL;
  
  // Just in case, limit pages amount to process.
  $max_pages_to_process = 30;
  $pages_processed = 0;
  
  do {
    $data = a4s_insta_queryGraphql_single($data_type, $username, $end_cursor, $items_per_query, $ds_user_id);
    
    // If we have an empty (FALSE) result from Instagram, break the look, and return FALSE, 
    // because we have now some failure and don't need to update the data now
    if (!$data) {
      return FALSE;
    }
    
    if (empty($data['edges'])) {
      $data = array();
    }
    else {
      $data_all = array_merge($data_all, $data['edges']);
    }
    if ($pages_count !== NULL) {
      --$pages_count;
    }
    if (++$pages_processed >= $max_pages_to_process || empty($data['page_info']['has_next_page']) || empty($data['page_info']['end_cursor']) || ($pages_count !== NULL && $pages_count <= 0) ) {
      $end_cursor = !empty($data['page_info']['end_cursor']) ? $data['page_info']['end_cursor'] : NULL;
      break;
    }
    $end_cursor = $data['page_info']['end_cursor'];
  }while(1);

  return $data_all;
}

/**
 * 
 * @param type $type
 * @param type $username
 * @param type $count
 * @param type $end_cursor
 * @return boolean
 */
function a4s_insta_queryGraphql_single($data_type, $username, $end_cursor = NULL, $items_per_query = 10, $ds_user_id = NULL, $dpm = FALSE) {
  
  //Example:
  //$variables = '{"id":"6218303298","first":10,"after":"AQCrgtZyW1dKfkQI8Xm7n4VmC_28FRCjFZ8ht_5WHNHsLJau_FwFjqdIB-yfqqJJk4sjA47Qd1SZHp-dS2yMej7-QuIdzzr0A6KwEOvs9CtxdA"}';
  //$url = "https://www.instagram.com/graphql/query/?query_hash=37479f2b8209594dde7facb0d904896a&variables=%7B%22id%22%3A%226218303298%22%2C%22first%22%3A10%2C%22after%22%3A%22AQC2c5Ud8R_m2Wagr8TnGYNRsQO-N0letvJFx7JH1NH3ySwey3NVgUF_uw7hdoyMgqouz1TBbZasNbIAoSlfDi_pxQm8bQvmkO7UFGhcQN_YvA%22%7D";
  //$end_cursor = 'AQCcbXzjdc_ZfOPp0T9xKt0lH-IYCbcbHjhF_NNy6R6DW19AnG4pGEKjYjPZXO5XezMQCPr7-fJWA63LWzY0Q3HfQ9jQ6zVjXYu1VO6dCwU_DA';

  $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
  if (empty($behat_insta_cookies['https://instagram.com'][$username]['ds_user_id'])) {
    return FALSE;
  }
  
  $behat_insta_cookies_user = $behat_insta_cookies['https://instagram.com'][$username];
  //Example:
  //$cookies_str = 'Cookie: csrftoken=GJ3PPaL2FfIQYA9J2RfkI2tYfdWeD0VD; ds_user_id=6218303298; sessionid=6218303298%3AUSbb2R456PKkYn%3A12; ';
  $cookies_str = 'Cookie: csrftoken=' . $behat_insta_cookies_user['csrftoken'] . '; ds_user_id=' . $behat_insta_cookies_user['ds_user_id'] . '; sessionid=' . $behat_insta_cookies_user['sessionid'] . '; ';
  
  switch ($data_type) {
    case 'followers':
      $query_hash = '37479f2b8209594dde7facb0d904896a'; // Folowers
      break;
    case 'following':
      $query_hash = '58712303d941c6855d4e888c5f0cd22f'; // Folowing
      break;
  }
  
  $variables = '{"id":' . '"' . ($ds_user_id ? $ds_user_id : $behat_insta_cookies_user['ds_user_id']) . '","first":' . $items_per_query . ',"after":"' . $end_cursor . '"}';
  $variables = urlencode($variables);
  $url = "https://www.instagram.com/graphql/query/?query_hash=$query_hash&variables=$variables";
  $results = a4s_insta_instagramCurlPage__withCookies($url, $cookies_str);
  
  if ($dpm) {
    dpm($results, '$results');
  }
  
  if (empty($results['data']['user'])) {
    return FALSE;
  }
  
  switch ($data_type) {
    case 'followers':
      $data = !empty($results['data']['user']['edge_followed_by']) ? $results['data']['user']['edge_followed_by'] : NULL;
      break;
    case 'following':
      $data = !empty($results['data']['user']['edge_follow']) ? $results['data']['user']['edge_follow'] : NULL;
      break;
  }
  return $data;
}

/**
 * 
 * @param type $url
 * @param type $cookies_str
 *  Example:  'Cookie: csrftoken=GJ3PPaL2FfIQYA9J2RfkI2tYfdWeD0VD; ds_user_id=6218303298; sessionid=6218303298%3AUSbb2R456PKkYn%3A12; '
 */
function a4s_insta_instagramCurlPage__withCookies($url, $cookies_str){
  $ch = curl_init($url);
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_POST, 0);
  curl_setopt($ch, CURLOPT_HTTPHEADER, array($cookies_str));
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  $results = json_decode(curl_exec($ch), TRUE);
  curl_close($ch);
  return $results;
}

/**
 * 
 * @param type $type
 * @param type $target
 * @param type $pages_count
 */
function a4s_insta_getDataMultiple($request_type, $data_type, $target, &$max_id, $pages_count = NULL, $dpm = FALSE) {
  $data = array();
  $data_all = array();
  
  // Just in case, limit pages amount to process.
  $max_pages_to_process = 30;
  $pages_processed = 0;
  
  do {
    switch ($request_type) {
      case 'fromRaw':
        $data = a4s_insta_getDataSingle__fromRaw($data_type, $target, $max_id, NULL, $dpm);
        break;
      case 'fromA':
        $data = a4s_insta_getDataSingle__fromA($data_type, $target, $max_id, $dpm);
        break;
    }
    
    if (!$data) {
      return FALSE;
    }
    
    $data_nodes = array();
    if (!empty($data['nodes'])) {
      $data_nodes = $data['nodes'];
    }
    elseif (!empty($data['edges'])) {
      $data_nodes = $data['edges'];
    }
    else {
      $data = array();
    }
    $data_all = array_merge($data_all, $data_nodes);
    if ($pages_count !== NULL) {
      --$pages_count;
    }
    $max_id = !empty($data['page_info']['end_cursor']) ? $data['page_info']['end_cursor'] : NULL;
    // Ignore $pages_count for a user/profile request
    if (++$pages_processed >= $max_pages_to_process || $data_type == 'user/profile' || empty($data['page_info']['has_next_page']) || empty($data['page_info']['end_cursor']) || ($pages_count !== NULL && $pages_count <= 0) ) {
      break;
    }
  }while(1);
  
  return $data_all;
}

/**
 * Custom file_get_contents() with exceptions handler.
 * @see https://stackoverflow.com/questions/272361/how-can-i-handle-the-warning-of-file-get-contents-function-in-php
 * 
 * @param type $url
 * @return boolean
 */
function a4s_instagram_file_get_contents($url, $dpm = FALSE) {
  $response = FALSE;
  //set_error_handler(create_function('$severity, $message, $file, $line', 'throw new ErrorException($message, $severity, $severity, $file, $line);'));

  try {
    $response = @file_get_contents($url);
    if ($response === FALSE) {
      if ($dpm) {
        dpm('a4s Insta Fetch-ERROR', 'NoException, $url: ' . $url . '; file_get_contents() rerurn = FALSE, no exception fired');
      }
      watchdog('a4s Insta Fetch-ERROR', 'NoException, $url: ' . $url . '; file_get_contents() rerurn = FALSE, no exception fired');
     }
     else {
       $response = trim($response);
     }
   } catch (Exception $e) {
      if ($dpm) {
        dpm('a4s Insta Fetch-ERROR', 'Exception, $url: ' . $url . '; file_get_contents() error ==> ' . $e->getMessage());
      }
      watchdog('a4s Insta Fetch-ERROR', 'Exception, $url: ' . $url . '; file_get_contents() error ==> ' . $e->getMessage());
   }

  //restore_error_handler();
  return $response;
}

/**
 * 
 * @param type $data_type
 * @param type $target
 * @param type $max_id
 * @return boolean|array
 */
function a4s_insta_getDataSingle__fromA($data_type, $target, $max_id = NULL, $dpm = FALSE) {
  switch ($data_type) {
    case 'user/profile':
    case 'user/media':
      $target_url = 'https://instagram.com/'. $target;
      break;
    case 'media/likers':
      $target_url = 'https://instagram.com/p/'. $target;
      break;
    case 'tag':
      $target_url = 'https://instagram.com/explore/tags/'. $target;
      break;
    default:
      return FALSE;
  }
  $target_url .= '?__a=1'; 
  if ($max_id) {
    $target_url .= '&max_id=' . $max_id; 
  }
  
  //$response = file_get_contents($target_url);
  $response = a4s_instagram_file_get_contents($target_url, $dpm);
  if ($response) {
      $data = json_decode($response, true);
      
      if ($dpm) {
        dpm($data, '$data fromA');
      }
      
      if (!empty($data)) {
          switch ($data_type) {
            case 'user/profile':
              $out = !empty($data['graphql']['user']) ? $data['graphql']['user'] : NULL;
              if (!empty($out)) {
                // Remove actual media data, as we return here only a general profile info
                //$data['user']['media']['nodes'] = array();
                $out['edge_owner_to_timeline_media']['edges'] = array();
              }
              /*
              $follows = $data['user']['follows']['count'];
              $followedBy = $data['user']['followed_by']['count'];
              dpm('$follows: ' . $follows . ', $followedBy: ' . $followedBy);
              */
              break;
            case 'user/media':
              //$out = !empty($data['user']['media']) ? $data['user']['media'] : NULL;
              $out = !empty($data['graphql']['user']['edge_owner_to_timeline_media']) ? $data['graphql']['user']['edge_owner_to_timeline_media'] : NULL;
              break;
            case 'media/likers':
              $out = !empty($data['graphql']['shortcode_media']['edge_media_preview_like']) ? $data['graphql']['shortcode_media']['edge_media_preview_like'] : NULL;
              break;
            case 'tag':
              $out = !empty($data['graphql']['hashtag']['edge_hashtag_to_media']) ? $data['graphql']['hashtag']['edge_hashtag_to_media'] : NULL;
              break;
          }
          return $out;
      }
  }
  return FALSE;
}

/**
 * 
 * @param type $own_account
 * @return boolean|string
 */
function a4s_insta_getCookies($own_account = 'all4senses') {
  $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
  if (empty($behat_insta_cookies['https://instagram.com'][$own_account]['ds_user_id'])) {
    return FALSE;
  }
  $behat_insta_cookies_user = $behat_insta_cookies['https://instagram.com'][$own_account];
  //Example:
  //$cookies_str = 'Cookie: csrftoken=GJ3PPaL2FfIQYA9J2RfkI2tYfdWeD0VD; ds_user_id=6218303298; sessionid=6218303298%3AUSbb2R456PKkYn%3A12; ';
  $cookies_str = 'Cookie: csrftoken=' . $behat_insta_cookies_user['csrftoken'] . '; ds_user_id=' . $behat_insta_cookies_user['ds_user_id'] . '; sessionid=' . $behat_insta_cookies_user['sessionid'] . '; ';
  return $cookies_str;
}

/**
 * https://gist.github.com/cosmocatalano/4544576
 * and fix instead of file_get_contents()
 * https://stackoverflow.com/questions/21677579/server-configuration-by-allow-url-fopen-0-in
 *'code' in media is an url tag for image, like https://www.instagram.com/p/BeQ84NSlzQN/
 *
 * @param type $data_type
 * @param type $target
 * @param type $max_id
 * @return array
 */
function a4s_insta_getDataSingle__fromRaw($data_type, $target, $max_id = NULL, $cookies_str = NULL, $dpm = FALSE) {
  switch ($data_type) {
    case 'user/profile':
    case 'user/media':
      $target_url = 'https://instagram.com/'. $target;
      //$cookies_str = a4s_insta_getCookies($own_account);
      break;
    
    case 'user/activity':
      
      /*
      $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
      if (empty($behat_insta_cookies['https://instagram.com'][$target]['ds_user_id'])) {
        return FALSE;
      }
      $behat_insta_cookies_user = $behat_insta_cookies['https://instagram.com'][$target];
      //Example:
      //$cookies_str = 'Cookie: csrftoken=GJ3PPaL2FfIQYA9J2RfkI2tYfdWeD0VD; ds_user_id=6218303298; sessionid=6218303298%3AUSbb2R456PKkYn%3A12; ';
      $cookies_str = 'Cookie: csrftoken=' . $behat_insta_cookies_user['csrftoken'] . '; ds_user_id=' . $behat_insta_cookies_user['ds_user_id'] . '; sessionid=' . $behat_insta_cookies_user['sessionid'] . '; ';
      */
      $cookies_str = a4s_insta_getCookies($own_account);
      
      
      $target_url = 'https://instagram.com/accounts/activity';
      break;
    case 'media/likers':
      $target_url = 'https://instagram.com/p/'. $target;
      break;
    case 'tag':
      $target_url = 'https://instagram.com/explore/tags/'. $target;
      break;
  }
  if ($max_id) {
    $target_url .= '?max_id=' . $max_id; 
  }
  
  if ($dpm) {
    dpm($target_url, '$target_url');
  }
  
  $insta_source = a4s_insta_instagramCurlPage__fromRaw($target_url, $cookies_str);
  //if ($dpm) {
  {
    dpm($insta_source, '$insta_source for '. $target_url);
  }
  
  if (empty($insta_source['content'])) {
    return NULL;
  }
  $shards = explode('window._sharedData = ', $insta_source['content']);
  $insta_json = explode(';</script>', $shards[1]); 
  $insta_array = json_decode($insta_json[0], TRUE);
  
  if ($dpm) {
    dpm($insta_array, '$insta_array fromRaw');
  }
  
  switch ($data_type) {
    case 'user/profile':
      $out = !empty($insta_array['entry_data']['ProfilePage'][0]['graphql']['user']) ? $insta_array['entry_data']['ProfilePage'][0]['graphql']['user'] : NULL;
      if (!empty($out)) {
        // Remove actual media data, as we return here only a general profile info
        //$out['media']['nodes'] = array();
        $out['edge_owner_to_timeline_media']['edges'] = array();
      }
      break;
    case 'user/media':
      //$out = !empty($insta_array['entry_data']['ProfilePage'][0]['user']['media']) ? $insta_array['entry_data']['ProfilePage'][0]['user']['media'] : NULL;
      $out = !empty($insta_array['entry_data']['ProfilePage'][0]['graphql']['user']['edge_owner_to_timeline_media']) ? $insta_array['entry_data']['ProfilePage'][0]['graphql']['user']['edge_owner_to_timeline_media'] : NULL;
      break;
    case 'user/activity':
      $out = !empty($insta_array['entry_data']['ActivityFeed'][0]['graphql']['user']['activity_feed']) ? $insta_array['entry_data']['ActivityFeed'][0]['graphql']['user']['activity_feed'] : NULL;
      //$out = !empty($insta_array['entry_data']['ActivityFeed'][0]['graphql']['user']['activity_feed']['edge_web_activity_feed']) ? $insta_array['entry_data']['ActivityFeed'][0]['graphql']['user']['activity_feed']['edge_web_activity_feed'] : NULL;
      break;
    case 'media/likers':
      $out = !empty($insta_array['entry_data']['PostPage'][0]['graphql']['shortcode_media']['edge_media_preview_like']) ? $insta_array['entry_data']['PostPage'][0]['graphql']['shortcode_media']['edge_media_preview_like'] : NULL;
      break;
    case 'tag':
      $out = !empty($insta_array['entry_data']['TagPage'][0]['graphql']['hashtag']['edge_hashtag_to_media']) ? $insta_array['entry_data']['TagPage'][0]['graphql']['hashtag']['edge_hashtag_to_media'] : NULL;
      break;
  }
  return $out;
}

/**
 * 
 * @param type $url
 * @param type $cookiesIn
 * @return type
 */
function a4s_insta_instagramCurlPage__fromRaw($url, $cookiesIn = ''){
            
    $options = array(
      CURLOPT_RETURNTRANSFER => true,     // return web page
      CURLOPT_HEADER         => true,     //return headers in addition to content
      CURLOPT_FOLLOWLOCATION => true,     // follow redirects
      CURLOPT_ENCODING       => "",       // handle all encodings
      CURLOPT_AUTOREFERER    => true,     // set referer on redirect
      CURLOPT_CONNECTTIMEOUT => 120,      // timeout on connect
      CURLOPT_TIMEOUT        => 120,      // timeout on response
      CURLOPT_MAXREDIRS      => 10,       // stop after 10 redirects
      CURLINFO_HEADER_OUT    => true,
      CURLOPT_SSL_VERIFYPEER => true,     // Validate SSL Cert
      CURLOPT_HTTP_VERSION   => CURL_HTTP_VERSION_1_1,
      CURLOPT_COOKIE         => $cookiesIn
    );

    $ch      = curl_init( $url );
    curl_setopt_array( $ch, $options );
    $rough_content = curl_exec( $ch );
    $err     = curl_errno( $ch );
    $errmsg  = curl_error( $ch );
    $header  = curl_getinfo( $ch );
    curl_close( $ch );
    
    $header_content = substr($rough_content, 0, $header['header_size']);
    $body_content = trim(str_replace($header_content, '', $rough_content));
    $pattern = "#Set-Cookie:\\s+(?<cookie>[^=]+=[^;]+)#m"; 
    preg_match_all($pattern, $header_content, $matches); 
    $cookiesOut = implode("; ", $matches['cookie']);

    $header['errno']   = $err;
    $header['errmsg']  = $errmsg;
    $header['headers']  = $header_content;
    $header['content'] = $body_content;
    $header['cookies'] = $cookiesOut;

    return $header;
}

/**
 * 
 */
function a4s_insta_get_images_to_click_byTags_allUsers_callback() {
  //return;
  //set_time_limit(0);

  $dpm = !empty($_GET['dpm']) ? TRUE : FALSE;
  
  $insta_users_tags = a4s_insta_get_user_tags();
  $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
  
  $insta_tags_pulled_last = variable_get('a4s_insta_tags_pulled_last', array());
  
  $behat_insta_users_keys = array_keys($behat_insta_cookies['https://instagram.com']);
  
  if (empty($insta_tags_pulled_last['username'])) {
    $insta_tags_pulled_last['username'] = current($behat_insta_users_keys);
    $insta_tags_pulled_last['tag'] = $insta_users_tags[$insta_tags_pulled_last['username']][0];
  }
  else {
    //$last_username_key = array_search($insta_cookies_tags_last['username'], $behat_insta_users_keys);
    $last_pulled_user_tags = $insta_users_tags[$insta_tags_pulled_last['username']];
    $last_pulled_tag_key = array_search($insta_tags_pulled_last['tag'], $last_pulled_user_tags);
    if ($last_pulled_tag_key + 1 >= count($last_pulled_user_tags)) {
       // It was the last tag for the previous user
       // So we have to switch to the next user and his first tag
      $last_pulled_user_key = array_search($insta_tags_pulled_last['username'], $behat_insta_users_keys);
      if ($last_pulled_user_key + 1 >= count($behat_insta_users_keys)) {
        $insta_tags_pulled_last['username'] = $behat_insta_users_keys[0];
      }
      else {
        $insta_tags_pulled_last['username'] = $behat_insta_users_keys[$last_pulled_user_key + 1];
      }
      $insta_tags_pulled_last['tag'] = $insta_users_tags[$insta_tags_pulled_last['username']][0];
    }
    else {
      $insta_tags_pulled_last['tag'] = $last_pulled_user_tags[$last_pulled_tag_key + 1];
    }
    
  }
  variable_set('a4s_insta_tags_pulled_last', $insta_tags_pulled_last);
  
  $added_tags_amount[$insta_tags_pulled_last['username']] = a4s_insta_get_images_to_click_byTags_singleUser($username = $insta_tags_pulled_last['username'], $tags = array($insta_tags_pulled_last['tag']), $min_medias_for_tag = 20, $max_medias_for_tag = 20, $dpm);
  
  if ($dpm) {
    dpm($added_tags_amount, '$added_tags_amount');
    return 'Finished processing.';
  }
  else {
    //drupal_json_output(array('New added tags amount' => $added_tags_amount));
    echo '<pre>' . print_r($added_tags_amount, TRUE) . '</pre>';
    drupal_exit();
  }
}

/**
 * 
 * @param type $username
 *  Example: 'olyayuskasova'
 * @param type $tags
 *  Example: array('design', 'art', 'interior');
 * @param type $min_medias_for_tag
 */
function a4s_insta_get_images_to_click_byTags_singleUser($username = 'olyayuskasova', $tags, $min_medias_for_tag = 20, $max_medias_for_tag = 20, $dpm = FALSE) {
  
  $like_conditions = a4s_insta_user_credentials_environment('https://instagram.com', $username)['like_conditions'];
  if ($dpm) {
    dpm($like_conditions, '$like_conditions');
  }
  
  $users_extra_data = array();
  
  $current_user_followers = db_select('a4s_insta_followers', 'f')
        ->fields('f', array('remote_id'))
        ->condition('f.is_following_now', 1)
        ->execute()
        ->fetchCol();
  
  $account_id = a4s_instagram_get_local_account_id_by_username($username);
  $added_tags_amount = array();
  $max_medias_by_owner_in_db_already = 3;
  
  $added_user_medias_in_this_session = array();
  $max_medias_per_user_for_session = 1;
  
  foreach ($tags as $tag) {
    $not_liked_by_tag = db_select('a4s_insta_clicks_by_tag', 'l')
        ->fields('l', array('shortcode'))
        ->condition('l.tag', $tag)
        ->condition('l.account_id', $account_id)
        ->isNull('l.liked')
        ->execute()
        ->fetchCol();
    $count_existing_in_db = $count_existing_in_db_before = count($not_liked_by_tag);
    $max_id = NULL;
    $tags_added = 0;
    while ($count_existing_in_db < $min_medias_for_tag) {
      //$results = a4s_insta_getDataMultiple('fromA', 'tag', $tag, $max_id, 1);
      $results = a4s_insta_getDataMultiple('fromRaw', 'tag', $tag, $max_id, 1);
      if (!$results) {
        break;
      }
      $media_to_db = array();
      foreach ($results as $result) {
        $result = $result['node'];
        
        // Skip a media, if it has disallowed likes amount
        if ($result['edge_liked_by']['count'] < $like_conditions['media']['likes']['from'] || $result['edge_liked_by']['count'] > $like_conditions['media']['likes']['to']) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because it has disallowed likes amount: ' . $result['edge_liked_by']['count']);
          }
          continue;
        }
        
        // Skip a media, if its owner is our follower already
        if (in_array($result['owner']['id'], $current_user_followers)) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because it is our follower already');
          }
          continue;
        }
        /*
        // Skip a media, if it's already is planned to be liked
        if (in_array($result['shortcode'], $not_liked_by_tag)) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because it is planned to be liked already');
          }
          continue;
        }
        */
        // Confine an amount of users to be liked per session
        $added_user_medias_in_this_session[$result['owner']['id']] = empty($added_user_medias_in_this_session[$result['owner']['id']]) ? 0 : $added_user_medias_in_this_session[$result['owner']['id']];
        if ($added_user_medias_in_this_session[$result['owner']['id']] >= $max_medias_per_user_for_session) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because we already have added ' . $max_medias_per_user_for_session . ' (max value) medias of this user in this session');
          }
          continue;
        }
        // Skip a media, if it's already is planned to be liked OR liked with maximum medias
        /*
        $medias_by_owner_in_db_already_count = db_select('a4s_insta_clicks_by_tag', 'l')
            ->fields('l', array('fid'))
            ->condition('l.tag', $tag)
            ->condition('l.media_owner_id', $result['owner']['id'])
            ->condition('l.account_id', $account_id)
            ->countQuery()->execute()->fetchField();
        */
        $medias_by_owner_in_db_already = db_select('a4s_insta_clicks_by_tag', 'l')
            ->fields('l', array('shortcode'))
            //->condition('l.tag', $tag)
            ->condition('l.media_owner_id', $result['owner']['id'])
            ->condition('l.account_id', $account_id)
            ->execute()->fetchCol();
        // Skip a media, if it's already is liked or planned to be liked
        if (in_array($result['shortcode'], $medias_by_owner_in_db_already)) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because it is planned to be liked already');
          }
          continue;
        }
        $medias_by_owner_in_db_already_count = count($medias_by_owner_in_db_already);
        if ($medias_by_owner_in_db_already_count >= $max_medias_by_owner_in_db_already) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because we already liked or planned to be liked ' . $max_medias_by_owner_in_db_already . ' medias of this user already');
          }
          continue;
        }
        // Skip a media if a summ of just added medias of this user and already liked or planned to be liked is more than $max_medias_by_owner_in_db_already
        if ($medias_by_owner_in_db_already_count + $added_user_medias_in_this_session[$result['owner']['id']] > $max_medias_by_owner_in_db_already) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because a summ of just added medias of this user (' . $added_user_medias_in_this_session[$result['owner']['id']] . ') and already liked or planned to be liked (' . $medias_by_owner_in_db_already_count . ') is more than ' . $max_medias_by_owner_in_db_already);
          }
          continue;
        }
        
        // Skip if a media has been already skipped to like before for some reason
        $already_skipped_to_like = db_select('a4s_insta_do_not_like_medias', 'n')
              ->fields('n', array('nid'))
              ->condition('n.shortcode', $result['shortcode'])
              ->condition('n.account_id', $account_id)
              ->execute()->fetchField();
        if ($already_skipped_to_like) {
          if ($dpm) {
            dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because it has been already skipped to like before for some reason');
          }
          continue;
        }
        
        // Skip if a media or its owner has disallowed amounts, etc
        if (empty($users_extra_data[$result['owner']['id']])) {
          $user_extra_data = db_select('a4s_insta_users_extra_data', 'e')
              ->fields('e', array('remote_id', 'username', 'followed_by_amount', 'following_amount', 'posts_amount'))
              ->condition('e.remote_id', $result['owner']['id'])
              ->execute()->fetchObject();
          $users_extra_data[$result['owner']['id']] = !$user_extra_data ? 'NA' : $user_extra_data;
        }
        if ($users_extra_data[$result['owner']['id']] != 'NA') {
          $user_extra_data = $users_extra_data[$result['owner']['id']];
          if ($user_extra_data->followed_by_amount < $like_conditions['user']['followers']['from'] || $user_extra_data->followed_by_amount > $like_conditions['user']['followers']['to']) {
            if ($dpm) {
              dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because its owner has disallowed follower amount ' . $user_extra_data->followed_by_amount);
              dpm($result, '$result');
              dpm($user_extra_data, '$user_extra_data');
            }
            continue;
          }
          if ($user_extra_data->following_amount < $like_conditions['user']['following']['from'] || $user_extra_data->following_amount > $like_conditions['user']['following']['to']) {
            if ($dpm) {
              dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because its owner has disallowed following amount ' . $user_extra_data->following_amount);
              dpm($result, '$result');
              dpm($user_extra_data, '$user_extra_data');
            }
            continue;
          }
          if ($user_extra_data->posts_amount < $like_conditions['user']['posts']['from'] || $user_extra_data->posts_amount > $like_conditions['user']['posts']['to']) {
            if ($dpm) {
              dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because its owner has disallowed posts amount ' . $user_extra_data->posts_amount);
              dpm($result, '$result');
              dpm($user_extra_data, '$user_extra_data');
            }
            continue;
          }
          if (!empty($like_conditions['user']['username_does_not_contain'])) {
            foreach ($like_conditions['user']['username_does_not_contain'] as $keyword) {
              if (strpos($user_extra_data->username, $keyword) !== FALSE) {
                if ($dpm) {
                  dpm('Skipped ' . $result['shortcode'] . ' (user ' . $result['owner']['id'] . '), because its owner username has disallowed substring in it: ' . $user_extra_data->username);
                  dpm($result, '$result');
                  dpm($user_extra_data, '$user_extra_data');
                }
                continue;
              }
            }
          }
          
        } // End of if ($users_extra_data[$result['owner']['id']] != 'NA') {
        
        
        
        $added_user_medias_in_this_session[$result['owner']['id']]++;
        
        $media_to_db[$result['shortcode']] = array(
          'account_id' => $account_id,
          'shortcode' => $result['shortcode'],
          'caption' => !empty($result['edge_media_to_caption']['edges'][0]['node']['text']) ? drupal_substr(utf8_encode($result['edge_media_to_caption']['edges'][0]['node']['text']), 0, 25) : NULL,
          'media_owner_id' => $result['owner']['id'],
          'tag' => $tag,
          'likes_amount' => $result['edge_liked_by']['count'],
          'thumbnail' => !empty($result['thumbnail_resources'][0]['src']) ? $result['thumbnail_resources'][0]['src'] : NULL,
          'is_video' => empty($result['is_video']) ? NULL : 1,
          'timestamp_taken' => $result['taken_at_timestamp'],
          'timestamp_added' => time(),
        );
        // Add to DB...
        $lid = db_insert('a4s_insta_clicks_by_tag')->fields(
                $media_to_db[$result['shortcode']]
               )->execute();
        
        $tags_added++;
        if ($tags_added >= $max_medias_for_tag) {
          break;
        }
      }
      $not_liked_by_tag = array_merge($not_liked_by_tag, array_keys($media_to_db));
      $count_existing_in_db = count($not_liked_by_tag);
    }
    if ($count_existing_in_db - $count_existing_in_db_before > 0) {
      watchdog('a4s get medias', 'Added ' . ($count_existing_in_db - $count_existing_in_db_before) . ' medias of a tag "' . $tag . '" for ' . $username);
    }
    $added_tags_amount[$tag] = $count_existing_in_db - $count_existing_in_db_before;
  }
  return $added_tags_amount;
}

/**
 * 
 * @param type $username
 * @return type
 */
function a4s_instagram_get_local_account_id_by_username($username) {
  
  $account_id = db_select('a4s_insta_own_users', 'u')
        ->fields('u', array('uid'))
        ->condition('u.username', $username)
        ->execute()->fetchField();
  
  return $account_id;
  /*
  $map_username_to_account_id_default = array('all4senses' => 1, 'olyayuskasova' => 2);
  $map_username_to_account_id = variable_get('a4s_map_username_to_account_id', $map_username_to_account_id_default);
  return !empty($map_username_to_account_id[$username]) ? $map_username_to_account_id[$username] : FALSE;
  */
}

/**
 * 
 * @param type $op
 *  'disable' OR 'enable'
 * 
 * @see https://stackoverflow.com/questions/38600772/is-there-a-way-to-configure-jenkins-to-stop-building-further-if-some-of-the-tes
 */
function a4s_instagram_jenkins_insta_switch_status($op = 'disable') {
  $url = "http://192.168.1.9:8181/job/Insta_v1/$op";
  $data = array($op => TRUE);
  $ch = curl_init($url);

  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_POST, count($data));
  curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

  $results = json_decode(curl_exec($ch), TRUE);
  curl_close($ch);
}
  
/**
 * 
 * @param type $account_id
 * @param type $username
 * @param type $tag
 * @param type $amount
 */
function a4s_instagram_set_user_medias_to_like($account_id = 1, $username, $username_remote_id, $tag = 'back-like', $amount = 2, $dpm = FALSE) {
  $media_indexes_to_like = array();
  $user_medias_to_like = array();
  $added_medias_amount = 0;
  $max_id = NULL;
  //$user_medias = a4s_insta_getDataSingle__fromA($data_type = 'user/media', $target = $username, $max_id = NULL);
  //$user_medias = a4s_insta_getDataMultiple('fromA', 'user/media', $username, $max_id, $pages_to_get = 2, $dpm);
  $user_medias = a4s_insta_getDataMultiple('fromRaw', 'user/media', $username, $max_id, $pages_to_get = 2, $dpm);
  if ($dpm) {
    dpm($user_medias, '$user_medias');
  }
  //if (!empty($user_medias['nodes']) && count($user_medias['nodes']) > 5) {
  if (!empty($user_medias) && $user_medias_count = count($user_medias)) {
    // Define $amount random indexes from first $pages_to_get = 2 users medias
    $max_iterations = 200;
    $already_liked_or_planned_array = array();
    for ($i = 0; $i < $amount; $i++) {
      $iterations = 0;
      do {
        $r =  mt_rand(1, $user_medias_count - 1);
        
        if (empty($already_liked_or_planned_array[$r])) {
          $already_liked_or_planned = db_select('a4s_insta_clicks_by_tag', 't')
            ->fields('t', array('cid'))
            ->condition('t.shortcode', $user_medias[$r]['node']['shortcode'])
            ->execute()->fetchField();
          $already_liked_or_planned_array[$r] = $already_liked_or_planned ? 'yes' : 'no';
        }
      //}while (in_array($r, $media_indexes_to_like) && ++$iterations < $max_iterations);
      }while ( ($already_liked_or_planned_array[$r] == 'yes' || in_array($r, $media_indexes_to_like) ) && ++$iterations < $max_iterations);
      
      $media_indexes_to_like[] = $r;
    }
    
    foreach ($media_indexes_to_like as $media_index_to_like) {
      $user_media = $user_medias[$media_index_to_like]['node'];
      $user_media_to_like_data = array(
        'account_id' => $account_id,
        //'shortcode' => $user_media['code'],
        'shortcode' => $user_media['shortcode'],
        
        //'caption' => !empty($user_media['caption']) ? drupal_substr(utf8_encode($user_media['caption']), 0, 25) : NULL,
        'caption' => !empty($user_media['edge_media_to_caption']['edges'][0]['node']['text']) ? drupal_substr(utf8_encode($user_media['edge_media_to_caption']['edges'][0]['node']['text']), 0, 25) : NULL,
        
        'media_owner_id' => $username_remote_id,
        'tag' => $tag,
        //'likes_amount' => $user_media['likes']['count'],
        'likes_amount' => $user_media['edge_liked_by']['count'],
        
        'thumbnail' => !empty($user_media['thumbnail_resources'][0]['src']) ? $user_media['thumbnail_resources'][0]['src'] : NULL,
        'is_video' => empty($user_media['is_video']) ? NULL : 1,
        //'timestamp_taken' => $user_media['date'],
        'timestamp_taken' => $user_media['taken_at_timestamp'],
        
        'timestamp_added' => REQUEST_TIME,
      );
      // Add to DB...
      $cid = db_insert('a4s_insta_clicks_by_tag')->fields(
              $user_media_to_like_data
             )->execute();
      if ($cid) {
        //$user_medias_to_like[] = $user_media['code'];
        $user_medias_to_like[] = $user_media['shortcode'];
      }
    }
    $added_medias_amount = count($user_medias_to_like);
    watchdog('a4s followers, like back', 'Added ' . $added_medias_amount . ' ['. $tag . '] medias to like for a follower (or unfollower) ' . $username);
    if ($dpm) {
      dpm($user_medias_to_like, "Added " . $added_medias_amount . " [$tag] medias to like for a follower (or unfollower) $username");
    }
  }
  return $added_medias_amount;
}

/**
 * 
 * @param type $username
 * @param type $dpm
 * @param type $dpm_all_new
 */
function a4s_instagram_update_activity_single_username($username = 'all4senses', $dpm = FALSE, $dpm_all_new = FALSE) {
  
  $account_id = a4s_instagram_get_local_account_id_by_username($username);
  $remote_activities = a4s_insta_getDataSingle__fromRaw('user/activity', $username);
  
  if ($dpm && $dpm_all_new) {
    dpm($remote_activities, '$remote_activities');
  }
  
  // Empty results... Cancel processing.
  if (empty($remote_activities['edge_web_activity_feed']['edges'])) {
    return;
  }
  
  $activity_types = array('1' => 'like', '2' => 'comment', '3' => 'follow');
  
  $new_activities = array();
  //$existing_activity = NULL;
  $report = array();
  
  // Get the latest last activity timestamp
  $last_activity_timestamp = db_select('a4s_insta_user_activities', 'a')
              ->fields('a', array('timestamp'))
              ->condition('a.account_id', $account_id)
              ->orderBy('a.timestamp', 'desc')
              ->range(0, 1)
              ->execute()->fetchField();
  
  foreach ($remote_activities['edge_web_activity_feed']['edges'] as $activity) {
    $activity = $activity['node'];
    $activity_timestamp = intval($activity['timestamp']);
    if ($activity_timestamp <= $last_activity_timestamp) {
      break;
    }
    
    /*
    $existing_activity = db_select('a4s_insta_user_activities', 'a')
              ->fields('a', array('aid'))
              ->condition('a.activity_id', $activity['id'])
              ->condition('a.account_id', $account_id)
              ->execute()->fetchField();
    */
    //if (empty($existing_activity)) {
      
      //dpm($activity['id'], 'empty event_id, for user ' . $activity['user']['username']);
      //dpm($existing_activity, '$existing_activity');
      $username = !empty($activity['user']['username']) ? $activity['user']['username'] : NULL;
      $activity_timestamp = intval($activity['timestamp']);
      $new_activities[] = array(
        'account_id' => $account_id,
        'activity_type' => $activity['type'],
        //'activity_id' => $activity['id'],
        'media_id' => !empty($activity['media']['id']) ? $activity['media']['id'] : NULL,
        'media_shortcode' => !empty($activity['media']['shortcode']) ? $activity['media']['shortcode'] : NULL,
        'media_thumbnail' => !empty($activity['media']['thumbnail_src']) ? $activity['media']['thumbnail_src'] : NULL,
        'user_id' => !empty($activity['user']['id']) ? $activity['user']['id'] : NULL,
        //'user_name' => $username,
        //'user_fullname' => !empty($activity['user']['full_name']) ? utf8_encode($activity['user']['full_name']) : NULL,
        //'user_thumbnail' => !empty($activity['user']['profile_pic_url']) ? $activity['user']['profile_pic_url'] : NULL,
        'extra_data' => !empty($activity['text']) ? drupal_substr(utf8_encode($activity['text']), 0, 97) : NULL,
        'timestamp' => $activity_timestamp,
      );
      $new_users[] = array(
        'remote_id' => !empty($activity['user']['id']) ? $activity['user']['id'] : NULL,
        'username' => $username,
        'fullname' => !empty($activity['user']['full_name']) ? utf8_encode($activity['user']['full_name']) : NULL,
        'thumbnail' => !empty($activity['user']['profile_pic_url']) ? $activity['user']['profile_pic_url'] : NULL,
      );
      $activity_type = isset($activity_types[$activity['type']]) ? $activity_types[$activity['type']] : 'other';
      $report[$activity_type][date('d/m/Y H:i:s', $activity_timestamp) . ' - '. $username] = $activity;
    //}
  }
  if ($dpm) {
    dpm($new_activities, '$new_activities');
    dpm($report, '$report');
  }
  for ($i = count($new_activities) - 1; $i >=0; $i--) {
    $aid = db_insert('a4s_insta_user_activities')->fields(
          $new_activities[$i]
         )->execute();
    $new_user = $new_users[$i];
    $existing_user = db_select('a4s_insta_users_extra_data', 'u')
              ->fields('u', array('remote_id', 'username', 'fullname', 'thumbnail'))
              ->condition('u.remote_id', $new_user['remote_id'])
              ->execute()->fetchObject();
    if (!$existing_user) {
      $eid = db_insert('a4s_insta_users_extra_data')->fields(array(
          'remote_id' => $new_user['remote_id'],
          'username' => $new_user['username'],
          'fullname' => $new_user['fullname'],
          'thumbnail' => $new_user['thumbnail'],
          'timestamp_added' => REQUEST_TIME,
         ))->execute();
    }
    else {
      db_update('a4s_insta_users_extra_data')
          ->fields(
              array(
                'username' => !empty($existing_user->username) ? $existing_user->username : $new_user['username'],
                'fullname' => !empty($existing_user->fullname) ? $existing_user->fullname : $new_user['fullname'],
                'thumbnail' => !empty($existing_user->thumbnail) ? $existing_user->thumbnail : $new_user['thumbnail'],
              )
            )
          ->condition('remote_id', $new_user['remote_id'])
          ->execute();
    }
  }
  if (!empty($report)) {
    watchdog('a4s activity', "$username: new activity ==> <pre>" . print_r($report, TRUE) . '</pre>');
  }
  return $report;
}


/**
 * 
 * @param type $username
 * @param type $dpm
 * @param type $dpm_all_new
 * @param type $dpm_all_existing
 * @return boolean
 */
function a4s_instagram_update_followers_single_username($username = 'all4senses', $dpm = FALSE, $dpm_all_new = FALSE, $dpm_all_existing = FALSE) {
  
  // Max difference between new and exsiting data to accept changes
  $max_difference = 30;
  
  $current_time = time();
  
  $existing_followers_unfollowed = array();
  $new_followers_remote_ids = array();
  $changed_followers = array();
  
  $account_id = a4s_instagram_get_local_account_id_by_username($username);
  
  $new_followers = a4s_insta_queryGraphql_multiple('followers', $username, $pages_count = NULL, $end_cursor = NULL, $items_per_query = 10);
  
  if(empty($new_followers)) {
    watchdog('a4s followers', "$username: => new_followers is EMPTY, possible failure to get the data from Instagram");
    if ($dpm) {
      dpm("$username: => new_followers is EMPTY, possible failure to get the data from Instagram");
    }
    return FALSE;
  }
  
      
  $new_followers_count = count($new_followers); 
  
  if  (!$new_followers_count) {
    watchdog('a4s followers', "$username: => new_followers = 0, possible failure to get the data from Instagram");
    if ($dpm) {
      dpm('$new_followers = 0, possible failure to get the data from Instagram');
      return FALSE;
    }
  }
  
  if ($dpm_all_new) {
    dpm($new_followers, '$new_followers');
  }
    
  // Get all existing followers (active and not active anymore)
  $query = db_select('a4s_insta_followers', 'f');
  $query->fields('f', array('fid', 'remote_id', 'followed_back', 'is_following_now', 'timestamp_unfollowed_first_time'));
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = f.remote_id');
  $query->fields('e', array('username', 'fullname'));  
  $query->condition('f.account_id', $account_id);
  $existing_followers = $query->execute()->fetchAllAssoc('remote_id');
  
  if ($dpm_all_existing) {
    dpm($existing_followers, '$existing_followers');
  }
  
  $existing_followers_count = 0;
  foreach ($existing_followers as $existing_follower) {
    if (!empty($existing_follower->is_following_now)) {
      $existing_followers_count++;
    }
  }
  
  // Skip updating if we feel that we just didn't get a correct data from the Instagram, because of the fetch failure.
  if ( ($existing_followers_count - $new_followers_count) > $max_difference) {
    watchdog('a4s followers', "$username: => existing_followers_count ($existing_followers_count) - new_followers_count ($new_followers_count) > max_difference ($max_difference), possible failure to get the data from Instagram");
    if ($dpm) {
      dpm("existing_followers_count ($existing_followers_count) - new_followers_count ($new_followers_count) > max_difference ($max_difference), possible failure to get the data from Instagram");
    }
    return FALSE;
  }
  
  if (!$existing_followers) {
    $existing_followers = array();
  }
  
  // Check for new and repeated followers
  foreach ($new_followers as $new_follower) {
    $update_existing = FALSE;
    $new_follower = $new_follower['node'];
    $new_follower['followed_by_viewer'] = $new_follower['followed_by_viewer'] ? 1 : 0;
    $new_followers_remote_ids[] = $new_follower['id'];
    $existing_follower = !empty($existing_followers[$new_follower['id']]) ? $existing_followers[$new_follower['id']] : NULL;
    
    if (!$existing_follower) {
      // We have a new follower
      // Add it to DB...
      $fid = db_insert('a4s_insta_followers')->fields(
            array(
              'account_id' => $account_id,
              'remote_id' => $new_follower['id'],
              //'username' => $new_follower['username'],
              //'full_name' => utf8_encode($new_follower['full_name']),
              //'thumbnail' => $new_follower['profile_pic_url'],
              'followed_back' => $new_follower['followed_by_viewer'],
              'timestamp_added' => $current_time,
              'timestamp_updated' => $current_time,
              'is_following_now' => 1,
            )
         )->execute();
      // Update or insert extra user data
      $existing_user_extra_data = db_select('a4s_insta_users_extra_data', 'e')
        ->fields('e', array('eid', 'username', 'fullname', 'remote_id', 'thumbnail'))
        ->condition('e.remote_id', $new_follower['id'])
        ->execute()
        ->fetchObject();
      $new_user_extra_data = array(
        'username' => $new_follower['username'],
        'fullname' => utf8_encode($new_follower['full_name']),
        'thumbnail' => $new_follower['profile_pic_url'],
      );
      if (!empty($existing_user_extra_data) && (empty($existing_user_extra_data->username) || empty($existing_user_extra_data->full_name) || empty($existing_user_extra_data->thumbnail)) ) {
        db_update('a4s_insta_users_extra_data')->fields($new_user_extra_data)->condition('eid', $existing_user_extra_data->eid)->execute();
      }
      else {
        $new_user_extra_data['remote_id'] = $new_follower['id'];
        $eid = db_insert('a4s_insta_users_extra_data')->fields($new_user_extra_data)->execute();
      }
      
      $changed_followers['added'][] = $new_follower;
      if ($dpm) {
        dpm($new_follower, 'NEW, not yet existing $new_follower');
      }
      
      // Plan to like several medias of this user in turn...
      // Actually we will do this instead when an activity of an account will be updated and we there will see this new follower
      // ...Along with new likers and commenters
      //a4s_instagram_set_user_medias_to_like($account_id, $new_follower['username'], $new_follower['id'], 'back-like', 2, $dpm);
      /*
      $new_follower_medias = a4s_insta_getDataSingle__fromA($data_type = 'user/media', $target = $new_follower['username'], $max_id = NULL);
      if (!empty($new_follower_medias['nodes']) && count($new_follower_medias['nodes']) > 10) {
        $new_follower_medias = $new_follower_medias['nodes'];
        $new_follower_medias_count = count($new_follower_medias);
        $new_follower_medias_to_like = array();
        $media_indexes_to_like = array($new_follower_medias_count - 1, intval($new_follower_medias_count/2));
        foreach ($media_indexes_to_like as $media_index_to_like) {
          $new_follower_media = $new_follower_medias[$media_index_to_like];
          $new_follower_media_to_like_data = array(
            'account_id' => $account_id,
            'shortcode' => $new_follower_media['code'],
            'caption' => !empty($new_follower_media['caption']) ? drupal_substr(utf8_encode($new_follower_media['caption']), 0, 25) : NULL,
            'media_owner_id' => $new_follower['id'],
            'tag' => 'back-like',
            'likes_amount' => $new_follower_media['likes']['count'],
            'thumbnail' => !empty($new_follower_media['thumbnail_resources'][0]['src']) ? $new_follower_media['thumbnail_resources'][0]['src'] : NULL,
            'is_video' => empty($new_follower_media['is_video']) ? NULL : 1,
            'timestamp_taken' => $new_follower_media['date'],
            'timestamp_added' => REQUEST_TIME,
          );
          // Add to DB...
          $cid = db_insert('a4s_insta_clicks_by_tag')->fields(
                  $new_follower_media_to_like_data
                 )->execute();
          $new_follower_medias_to_like[] = $new_follower_media['code'];
        }
        watchdog('a4s followers, like back', 'Added ' . count($new_follower_medias_to_like) . ' medias to like for a new follower ' . $new_follower['username']);
        if ($dpm) {
          dpm($new_follower_medias_to_like, 'Added medias to like for a new follower ' . $new_follower['username']);
        }
      }
      */
      
      
    }
    else {
      if (!$existing_follower->is_following_now) {
        // This follower has become a follower repeatedly 
        $rid = db_insert('a4s_insta_followers_repeated_followings')->fields(
            array(
              'fid' => $existing_follower->fid,
              'event_type' => 1, // Follower again
              'timestamp' => $current_time,
            )
         )->execute();
        $update_existing = TRUE;
        if ($dpm) {
          dpm($new_follower, '$new_follower...This follower has become a follower repeatedly');
        }
      }
      
      if ($update_existing || $existing_follower->followed_back != $new_follower['followed_by_viewer']) {
        db_update('a4s_insta_followers')
            ->fields(
                array(
                  'followed_back' => $new_follower['followed_by_viewer'],
                  'timestamp_updated' => $current_time,
                  'is_following_now' => 1,
                )
              )
            ->condition('account_id', $account_id)
            ->condition('remote_id', $new_follower['id'])
            ->execute();
        
        
        $changed_followers['updated'][] = $new_follower;
        if ($existing_follower->followed_back != $new_follower['followed_by_viewer']) {
          if ($dpm) {
            dpm($new_follower, '$new_follower... Changed followed_back/followed_by_viewer status');
          }
        }
      }
    } // End of else of if (!$existing_follower) {
  } // End of foreach ($results as $new_follower) {
  
  // Check for unfollowed followers
  foreach ($existing_followers as $existing_follower) {
    
    if (!in_array($existing_follower->remote_id, $new_followers_remote_ids)) {
        
        if (!$existing_follower->is_following_now) {
          $existing_followers_unfollowed[] = (array) $existing_follower;
//          if ($dpm) {
//            dpm($existing_follower, 'Still not follower, no changes');
//          }
        }
        else {
            // This follower has been unfollowed
            if (!$existing_follower->timestamp_unfollowed_first_time) {
              if ($dpm) {
                dpm($existing_follower, '$existing_follower ...unfollowing for the first time... we have to update our data in the main table');
              }
              // It's unfollowing for the first time
              // We update only the main follower table and a fields timestamp_unfollowed_first_time and is_following_now
              db_update('a4s_insta_followers')
                  ->fields(
                      array(
                        'is_following_now' => 0,
                        'timestamp_updated' => $current_time,
                        'timestamp_unfollowed_first_time' => $current_time,
                      )
                    )
                  ->condition('account_id', $account_id)
                  ->condition('remote_id', $existing_follower->remote_id)
                  ->execute();

              $changed_followers['unfollowed_first_time'][] = (array) $existing_follower;
              
              // Plan to like 1 media of this user, just to get some user statistics, if it's not yet recieved
              // Get a user statistics
              $existing_follower_statistics = db_select('a4s_insta_users_extra_data', 'd')
                ->fields('d', array('eid'))
                ->condition('d.remote_id', $existing_follower->remote_id)
                ->execute()
                ->fetchField();
              if (!$existing_follower_statistics) {
                a4s_instagram_set_user_medias_to_like($account_id, $existing_follower->username, $existing_follower->remote_id, 'unfollow-like', 1, $dpm);
              }
            }
            else {
              if ($dpm) {
                dpm($existing_follower, '$existing_follower ...repeatedly unfollowed.. we add unfollow to the a4s_insta_followers_repeated_followings and update');
              }
              // Or else it's repeatedly unfollowing
              $rid = db_insert('a4s_insta_followers_repeated_followings')->fields(
                  array(
                    'fid' => $existing_follower->fid,
                    'event_type' => 0, // UnFollower again
                    'timestamp' => $current_time,
                  )
               )->execute();

              db_update('a4s_insta_followers')
                  ->fields(
                      array(
                        'is_following_now' => 0,
                        'timestamp_updated' => $current_time,
                      )
                    )
                  ->condition('account_id', $account_id)
                  ->condition('remote_id', $existing_follower->remote_id)
                  ->execute();

              $changed_followers['unfollowed_repeatedly'][] = (array) $existing_follower;
            }
        }
    }
  }
  //if ($dpm) {
  //  dpm($changed_followers, '$changed_followers, final results');
  //}
  
  if (!empty($changed_followers)) {
    $fields_to_unset = array('id', 'fullname', 'profile_pic_url', 'is_verified', 'requested_by_viewer');
    foreach ($changed_followers as $data_set_key => $data_set) {
      foreach ($data_set as $data_key => $data) {
        foreach ($fields_to_unset as $field_to_unset) {
          unset($changed_followers[$data_set_key][$data_key][$field_to_unset]);
        }
      }
    }
  }
  if ($dpm) {
    dpm($changed_followers, '$changed_followers, final results, after cleaning');
    if (!empty($existing_followers_unfollowed)) {
      dpm($existing_followers_unfollowed, '$existing_followers_unfollowed - not in new followers, BUT in DB, already marked before as not followers anymore');
    }
  }
  watchdog('a4s followers', "$username: => <pre>" . print_r($changed_followers, TRUE) . '</pre>');
    
  return $changed_followers;
}

/**
 * 
 */
function a4s_instagram_update_followers_all_users_callback() {
  // Process different user every time
  $users_to_process = array('olyayuskasova', 'all4senses');

  $last_followers_update_user = variable_get('a4s_insta_last_followers_update_user', array());

  if (count($users_to_process) > 1) {
    if (empty($last_followers_update_user)) {
      $current_user = $users_to_process[0];
    }
    else {
      foreach ($users_to_process as $key => $user) {
        if ($user == $last_followers_update_user) {
          if ($key + 1 >= count($users_to_process)) {
            $current_user = $users_to_process[0];
          }
          else {
            $current_user = $users_to_process[$key + 1];
          }
        }
      }
    }
  }
  else {
    $current_user = $users_to_process[0];
  }
  variable_set('a4s_insta_last_followers_update_user', $current_user);
  
  $results = a4s_instagram_update_followers_single_username($current_user);
  if (!empty($results)) {
    foreach ($results as $key => &$data) {
      $data = count($data);
    }
  }
  drupal_json_output(array("Updated followers for $current_user" => $results));
}

/**
 * 
 */
function a4s_instagram_update_activity_all_users_callback() {
  // Process different user every time
  $users_to_process = array('olyayuskasova', 'all4senses');

  $last_activity_update_user = variable_get('a4s_insta_last_activity_update_user', array());

  if (count($users_to_process) > 1) {
    if (empty($last_activity_update_user)) {
      $current_user = $users_to_process[0];
    }
    else {
      foreach ($users_to_process as $key => $user) {
        if ($user == $last_activity_update_user) {
          if ($key + 1 >= count($users_to_process)) {
            $current_user = $users_to_process[0];
          }
          else {
            $current_user = $users_to_process[$key + 1];
          }
        }
      }
    }
  }
  else {
    $current_user = $users_to_process[0];
  }
  variable_set('a4s_insta_last_activity_update_user', $current_user);
  
  $results = a4s_instagram_update_activity_single_username($current_user);
  if (!empty($results)) {
    foreach ($results as $key => &$data) {
      $data = count($data);
    }
  }
  drupal_json_output(array("Updated activity for $current_user" => $results));
}

/**
 * 
 * @param type $follower_username
 * @param type $account_username
 */
function a4s_instagram_get_follower_info($follower_username, $account_username = 'all4senses', $account_id = NULL) {
  if (!$account_id) {
    $account_id = a4s_instagram_get_local_account_id_by_username($account_username);
  }
  $follower_data = array();
  
  $query = db_select('a4s_insta_followers', 'f')
    ->fields('f', array());
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = f.remote_id');
  $query->fields('e', array('username', 'fullname', 'thumbnail'));  
  $query->condition('f.account_id', $account_id)
        ->condition('e.username', $follower_username);
  $follower_data['main'] = $query->execute()->fetchObject();
  
  if (empty($follower_data['main'])) {
    return NULL;
  }
  
  $fields_to_convert_time = array('timestamp_added', 'timestamp_unfollowed_first_time', 'timestamp_updated');
  foreach ($fields_to_convert_time as $field_to_convert_time) {
    if (empty($follower_data['main']->{$field_to_convert_time})) {
      $follower_data['main']->{$field_to_convert_time} = 'N/A';
    }
    else {
      $follower_data['main']->{$field_to_convert_time} = date('d/m/Y H:i', $follower_data['main']->{$field_to_convert_time});
    }
  }

  // Get a user statistics
  $follower_data['user_statistics'] = db_select('a4s_insta_users_extra_data', 'd')
    ->fields('d', array('followed_by_amount', 'following_amount', 'posts_amount'))
    ->condition('d.remote_id', $follower_data['main']->remote_id)
    ->execute()
    ->fetchObject();
  
  // Get a user liked by us medias
  $follower_data['auto_liked_medias'] = db_select('a4s_insta_clicks_by_tag', 'm')
    ->fields('m', array('shortcode'))
    ->condition('m.account_id', $account_id)
    ->condition('m.media_owner_id', $follower_data['main']->remote_id)
    ->execute()
    ->fetchCol();
  
  // Get repeated following/unfollowing data
  $follower_data_extra = db_select('a4s_insta_followers_repeated_followings', 'f')
    ->fields('f', array())
    ->condition('f.fid', $follower_data['main']->fid)
    ->execute()
    ->fetchAllAssoc('timestamp');
  
  if (!empty($follower_data_extra)) {
    foreach ($follower_data_extra as $key => $data) {
      $new_data = $data;
      $new_data->timestamp = date('d/m/Y H:i', $new_data->timestamp);
      unset($follower_data_extra[$key]);
      $follower_data_extra[$new_data->timestamp . ' - ' . ($new_data->event_type ? 'followed' : 'unfollowed')] = $new_data;
    }
    $follower_data['extra'] = $follower_data_extra;
  }
    
  //dpm($follower_data, '$follower_data');
  return $follower_data;
}

/**
 * 
 * @param type $target_username
 * @param type $target_user_id
 * @param type $account_username
 * @param type $account_id
 * @return type
 */
function a4s_instagram_get_user_statistics__relatedToRequestedAccount($target_username, $target_user_id, $account_username = 'all4senses', $account_id = NULL) {
  if (!$account_id) {
    $account_id = a4s_instagram_get_local_account_id_by_username($account_username);
  }
  $user_data = array();
  $user_data['follower'] = db_select('a4s_insta_followers', 'f')
    ->fields('f', array('fid', 'followed_back', 'timestamp_unfollowed_first_time', 'is_following_now'))
    ->condition('f.account_id', $account_id)
    ->condition('f.remote_id', $target_user_id)
    ->execute()
    ->fetchObject();
  
  $user_data['repeating_following'] = NULL;
  if(!empty($user_data['follower'])) {
    // Get repeated following/unfollowing data
    $follower_data_extra = db_select('a4s_insta_followers_repeated_followings', 'f')
      ->fields('f', array())
      ->condition('f.fid', $user_data['follower']->fid)
      ->execute()
      ->fetchAllAssoc('timestamp');
    
    if (!empty($follower_data_extra)) {
      foreach ($follower_data_extra as $key => $data) {
        $new_data = $data;
        $new_data->timestamp = date('d/m/Y H:i', $new_data->timestamp);
        unset($follower_data_extra[$key]);
        $follower_data_extra[$new_data->timestamp . ' - ' . ($new_data->event_type ? 'followed' : 'unfollowed')] = $new_data;
      }
      $user_data['repeating_following'] = $follower_data_extra;
    }
  }
  
  // Get a user liked by us medias
  $query = db_select('a4s_insta_clicks_by_tag', 'm')
      ->fields('m', array('shortcode'))
      ->condition('m.account_id', $account_id)
      ->condition('m.media_owner_id', $target_user_id);
    //$query->execute()->fetchCol();
  $user_data['auto_liked_medias'] = $query->countQuery()->execute()->fetchField();
  
  return $user_data;
}

/**
 * 
 * @return string
 */
function a4s_instagram_likes_history_page() {
  
  $args = arg();
  if (empty($args[2]) || !$account_id = a4s_instagram_get_local_account_id_by_username($args[2])) {
    return 'Wrong request...';
  }
 
  $last_hours = !empty($args[3]) ? $args[3] : variable_get('a4s_insta_history_period_hours_default', 12);
  $out = '';
  
  $query = db_select('a4s_insta_clicks_by_tag', 't')
        ->fields('t', array())
        ->condition('t.account_id', $account_id)
        ->condition('t.liked', 1)
        ->condition('t.timestamp_liked', REQUEST_TIME - (60*60*$last_hours), '>'); // for last 1 hour
      
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = t.media_owner_id');
  $query->fields('e', array('username', 'followed_by_amount', 'following_amount', 'posts_amount'));  

  $query->leftJoin('a4s_insta_followers', 'f', 'f.remote_id = t.media_owner_id');
  $query->fields('f', array('is_following_now'));  

  $query->orderBy('t.timestamp_liked', 'desc');
  $likes = $query->execute()->fetchAllAssoc('cid');
  
  $skipped_likes = db_select('a4s_insta_do_not_like_medias', 'n')
        ->fields('n', array('shortcode'))
        ->condition('n.account_id', $account_id)
        ->condition('n.timestamp', REQUEST_TIME - (60*60*$last_hours), '>')
        ->execute()->fetchCol();
        //->countQuery()->execute()->fetchField();
  $skipped_likes_count = count($skipped_likes);
  
  //dpm($likes, '$likes');
  $out .= '<div>Total liked: ' . count($likes) . '</div><div>Skipped: ' . $skipped_likes_count . '</div><br/>';
  
  if (!empty($likes)) {
    $out .= '<div class="liked-medias" style="overflow: hidden;">';
    foreach ($likes as $like) {
      
      $count_user_liked = db_select('a4s_insta_clicks_by_tag', 't')
        ->fields('t', array('cid'))
        ->condition('t.media_owner_id', $like->media_owner_id)
        ->condition('t.liked', 1)
        //->condition('t.timestamp_liked', REQUEST_TIME - (60*60*$last_hours), '>'); // for last 1 hour
        ->countQuery()->execute()->fetchField();
      $out .= '<div class="like" style="float:left; width:140px; height:410px; margin-right:5px; margin-bottom:30px;">'
              //. '<div class="like-tag"><a href="https://instagram.com/explore/tags/' . utf8_decode($like->tag) . '">' . utf8_decode($like->tag) . '</a></div>'
              . '<div class="like-tag">Tag: <a href="https://instagram.com/explore/tags/' . $like->tag . '">' . $like->tag . '</a></div>'
              . '<div class="like-title" style="margin-bottom=5px; height:47px;">Title: <a href="https://instagram.com/p/' . $like->shortcode . '">' . utf8_decode($like->caption) . '</a></div>'
              . '<div class="like-item">Likes <span style="font-size: 11px;">(when added)</span>: ' . $like->likes_amount . '</div>'
              . '<div class="like-item">Liked: <span style="font-size: 11px;">' . date('d/m/Y H:i', $like->timestamp_liked) . '</span></div>'
              . '<div class="like-item">Taken: <span style="font-size: 11px;">' . date('d/m/Y H:i', $like->timestamp_taken) . '</span></div>'
              . '<div class="like-img"><a href="https://instagram.com/p/' . $like->shortcode . '"><img width="130px" src="' . $like->thumbnail . '"></a></div>'
              
              . '<div class="like-item">User: <a style="display:block;" href="https://instagram.com/' . $like->username . '">' . $like->username . '</a></div>'
              . '<div class="like-item">User followers: ' . $like->followed_by_amount . '</div>'
              . '<div class="like-item">User following: ' . $like->following_amount . '</div>'
              . '<div class="like-item">User posts: ' . $like->posts_amount . '</div>'
              . '<div class="like-item">I liked ' . $count_user_liked . ' his medias</div>'
              . '<div class="like-item"><span style="color:' . ($like->is_following_now ? 'green;">My follower' : 'red;">Not my follower') . '</span></div>'
          
            . '</div>';
    }
    $out .= '</div>';
  }
  if (!empty($skipped_likes)) {
    $out .= '<div class="skipped-likes"><div class="title" style="font-weight:bold; color:red;">Skipped to like medias</div>';
    foreach ($skipped_likes as $shortcode) {
      $out .= '<div class="skipped-like" style="float:left;"><a style="padding-right:10px;" href="https://instagram.com/p/' . $shortcode . '">' . $shortcode . '</a></div>';
    }
    $out .= '</div>';
  }
  
  return "<h1 class='page-header' style='letter-spacing:12px;'>Likes for the last $last_hours hours:</h1><br/>'$out";
}

/**
 * 
 * @return string
 */
function a4s_instagram_followers_history_page() {
  
  $args = arg();
  if (empty($args[2]) || !$account_id = a4s_instagram_get_local_account_id_by_username($args[2])) {
    return 'Wrong request...';
  }
 
  $last_hours = !empty($args[3]) ? $args[3] : variable_get('a4s_insta_history_period_hours_default', 12);
  $out = '';
  
  $query = db_select('a4s_insta_followers', 'f');
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = f.remote_id');
  $query->fields('e', array('username'));  
  $query->condition('f.account_id', $account_id)
        ->condition('f.timestamp_updated', REQUEST_TIME - (60*60*$last_hours), '>'); // for last 1 hour
  $followers = $query->orderBy('f.timestamp_updated', 'desc')->execute()->fetchCol();
  
  $unfollowed = 0;
  $new_followers = 0;
  $changed = '';
  $followers_data = array();
  if (!empty($followers)) {
    foreach ($followers as $follower_username) {
      $follower_data = a4s_instagram_get_follower_info($follower_username, $account_username = NULL, $account_id);
      $followers_data[] = $follower_data;
      if (empty($follower_data['main'])) {
        continue;
      }
      if ($follower_data['main']->is_following_now) {
        $new_followers++;
      }
      else {
        $unfollowed++;
      }
      $changed .= '<div class="follower" style="float:left; width:140px; height:390px; margin-right:5px; margin-bottom:30px;">'
              . '<div class="follower-type">' . ($follower_data['main']->is_following_now ? '<span style="color:limegreen;">Following from:</span>' : '<span style="color:red;">Unfollowed from:</span>') .  (!empty($follower_data['extra']) ? '<span title="' . print_r($follower_data['extra'], TRUE) . '"  style="background:yellow; float:right; margin-right:10px; padding:0 3px; cursor:help;">R</span>' : '') . '</div>'
              . '<div class="like-title" style="height:50px;"><a href="https://instagram.com/' . $follower_data['main']->username . '">' . utf8_decode($follower_data['main']->fullname) . '</a></div>'
              . '<div class="follower-date" style="margin-bottom:10px;"><div>Updated:</div>' . $follower_data['main']->timestamp_updated . '</div>'
              . '<div class="follower-date" style="margin-bottom:10px;"><div>Added:</div>' . $follower_data['main']->timestamp_added . '</div>'
              
              . '<div class="like-ifollow">' . ($follower_data['main']->followed_back ? '<span style="color:white; background:green; display:block; padding:0 5px;">I follow</span>' : '<span style="color:white; background:lightgray; display:block; padding:0 5px;">I dont follow</span>') . '</div>'
              . '<div class="follower-img"><a href="https://instagram.com/' . $follower_data['main']->username . '"><img width="130px" src="' . $follower_data['main']->thumbnail . '"></a></div>'
              . '<div class="follower-item">Auto liked by me: ' . count($follower_data['auto_liked_medias']) . '</div>'
              . (empty($follower_data['user_statistics']) ? '' : ''
                  . '<div class="follower-item" style="margin-top:5px;">Followers: ' . $follower_data['user_statistics']->followed_by_amount . '</div>'
                  . '<div class="follower-item">Following: ' . $follower_data['user_statistics']->following_amount . '</div>'
                  . '<div class="follower-item">Posts: ' . $follower_data['user_statistics']->posts_amount . '</div>'
                )
            . '</div>';
    }
  }
  
  $out .= '<div>Total changed: ' . count($followers) . " (unfollowed: $unfollowed, new followers: $new_followers)</div><br/>";
  $out .= $changed;
      
  //dpm($followers_data, '$followers_data');
  return "<h1 class='page-header' style='letter-spacing:3px;'>Followers changes for the last $last_hours hours:</h1><br/>'$out";
}

/**
 * 
 * @return string
 */
function a4s_instagram_activity_history_page() {
  
  $args = arg();
  if (empty($args[2]) || !$account_id = a4s_instagram_get_local_account_id_by_username($args[2])) {
    return 'Wrong request...';
  }
 
  $last_hours = !empty($args[3]) ? $args[3] : variable_get('a4s_insta_history_period_hours_default', 12);
  $out = '';
  $changed = '';
  
  $query = db_select('a4s_insta_user_activities', 'a')
    ->fields('a', array())
    ->condition('a.account_id', $account_id)
    ->condition('a.timestamp', REQUEST_TIME - (60*60*$last_hours), '>'); // for last 1 hour
      
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = a.user_id');
  $query->fields('e', array('username', 'fullname', 'followed_by_amount', 'following_amount', 'posts_amount', 'thumbnail'));  
  $query->orderBy('a.timestamp', 'desc');
  $activities = $query->execute()->fetchAllAssoc('aid');
  
  $activity_types = array(1 => 'Liked Your:', 2 => 'Commented Your:', 3 => 'Following You', 4 => 'Other (4)', 5 => 'Commented back:');
  $counts = array(1 => 0, 2 => 0, 3 => 0, 4 => 0, 5 => 0);
  if (!empty($activities)) {
    foreach ($activities as $activity) {
      $counts[$activity->activity_type]++;
      
      $user_extra_data = a4s_instagram_get_user_statistics__relatedToRequestedAccount($activity->username, $activity->user_id, $account_username = NULL, $account_id);
      
      $changed .= '<div class="activity" style="float:left; width:140px; height:520px; margin-right:5px; margin-bottom:30px;">'
              . '<div class="activity-date" style="margin-bottom:10px;">' . date('d/m/Y H:i', $activity->timestamp) . '</div>'
              . '<div class="user-title" style="height:50px;"><a href="https://instagram.com/' . $activity->username . '">' . utf8_decode($activity->fullname) . '</a></div>'
              
              . '<div class="user-img"><a href="https://instagram.com/' . $activity->username . '"><img width="130px" src="' . $activity->thumbnail . '"></a></div>'
                  . '<div class="user-item" style="margin-top:5px;">Followers: ' . $activity->followed_by_amount . '</div>'
                  . '<div class="user-item">Following: ' . $activity->following_amount . '</div>'
                  . '<div class="user-item">Posts: ' . $activity->posts_amount . '</div>'
                  
                  . '<div class="user-item">Your follower: ' . (!empty($user_extra_data['follower']) && $user_extra_data['follower']->is_following_now ? '<span style="color:white;background:green;">Yes' : '<span style="color:red;">' . (!empty($user_extra_data['follower']) && !$user_extra_data['follower']->is_following_now ? 'Not anymore' : 'No') . '</span>') . (!empty($user_extra_data['repeating_following']) ? '<span title="' . print_r($user_extra_data['repeating_following'], TRUE) . '"  style="background:yellow; float:right; margin-right:10px; padding:0 3px; cursor:help;">R</span>' : '') . '</div>'
                  . '<div class="user-item">You follow him: ' . (!empty($user_extra_data['follower']) ? ($user_extra_data['follower']->followed_back ? 'Yes' : 'No') : 'N/A') . '</div>'
                  . '<div class="user-item">Auto liked by me: ' . count($user_extra_data['auto_liked_medias']) . '</div>'
          
                  . '<div class="activity-type" style="margin-top:20px; ' . ($activity->activity_type == 3 ? 'background:green; color:white;' : 'color:green;') . '">' . $activity_types[$activity->activity_type] . '</div>'
                  
                  . (empty($activity->media_thumbnail) ? '' : 
                      (
                         '<div class="media-img"><a href="https://instagram.com/p/' . $activity->media_shortcode . '"><img width="70px" src="' . $activity->media_thumbnail . '"></a></div>'
                       . '<div class="media-item">Liked back: ' . ($activity->activity_local_status ? 'Yes' : 'No') . '</div>'
                       . (!$activity->extra_data ? '' : '<div class="media-item">Comment: ' . $activity->extra_data . '</div>')
                      )
                    )
            . '</div>';
    }
  }
  
  $short_report = '';
  foreach ($counts as $key => $value) {
    if ($value) {
      $short_report .= ($short_report ? ', ' : '') . $activity_types[$key] . ' ' . $value;
    }
  }
  $out .= '<div>' . $short_report . '</div><br/>';
  $out .= $changed;
      
  return "<h1 class='page-header' style='letter-spacing:3px;'>Activities for the last $last_hours hours:</h1><br/>'$out";
}

/**
 * 
 * @param type $dpm
 * @param type $max_session_users_to_like
 * @param type $amount_to_like_followers
 * @param type $amount_to_like_likers
 * @param type $amount_to_like_multiple_likers
 * @return string
 */
function a4s_instagram_get_newLikersAndFollowers_mediasToBackLike_callback($dpm = FALSE, $max_session_users_to_like = 1, $amount_to_like_followers = 3, $amount_to_like_likers = 2, $amount_to_like_multiple_likers = 3) {

  $dpm = (!$dpm && empty($_GET['dpm'])) ? FALSE : TRUE;
  $max_session_users_to_like = !empty($_GET['users-per-session']) ? $_GET['users-per-session'] : $max_session_users_to_like;
  
  $hours_to_skip_liking = 10;
  
  $query = db_select('a4s_insta_user_activities', 'a')
    ->fields('a', array('aid', 'account_id', 'activity_type', 'user_id', 'failed'));
  
  $query->isNull('a.activity_local_status');
  $db_or = db_or()->isNull('a.failed')->condition('a.failed', 2, '<');
  $query->condition($db_or);
  //$query->condition('a.failed', 2, '<');
  
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = a.user_id');
  $query->fields('e', array('username'));  
  $query->orderBy('a.timestamp', 'asc');
  //$query->range(0, $max_session_users_to_like);
  if(!$activities = $query->execute()->fetchAllAssoc('aid')) {
    if ($dpm) {
      dpm(array('Back-likes for new activities: ' => 'No new activities'), 'Empty activities result');
      return 'Finished processing. No new unprocessed activities found';
    }
    drupal_json_output(array('Back-likes for new activities: ' => 'No new activities'));
    drupal_exit();
  }
  
  $this_session_users_to_like = 0;
  $users_events = array();
  $users_to_like = array();
  $users_to_like_success = array();
  
  foreach ($activities as $aid => $activity) {
    $users_events_per_account[$activity->account_id][$activity->username][] = $aid;
  }
  foreach ($users_events_per_account as $account_id => $target_users) {
    foreach ($target_users as $target_username => $target_username_data) {
      if (count($target_username_data) > 1) {
        $amount_to_like = $amount_to_like_multiple_likers;
      }
      else {
        $amount_to_like = $amount_to_like_likers;
        foreach ($target_username_data as $aid) {
          if ($activities[$aid]->activity_type == 3) {
            $amount_to_like = $amount_to_like_followers;
            break;
          }
        }
      }
      $users_to_like[$account_id][$target_username] = $amount_to_like;
      if (++$this_session_users_to_like >= $max_session_users_to_like) {
        break 2;
      }
    }
  }
  
  $events_to_set_processed = array();
//  foreach ($users_to_like as $account_id => $target_users) {
//    foreach ($target_users as $target_username => $amount_to_like) {
//      $events_to_set_processed = array_merge($events_to_set_processed, $users_events_per_account[$account_id][$target_username]);
//    }
//  }
  
  
  // Plan to like several medias of this user in turn...
  foreach ($users_to_like as $account_id => $users) {
    foreach ($users as $username => $amount_to_like) {
      if ($dpm) {
        dpm('$account_id: ' . $account_id . ', $username: ' . $username . ', $amount_to_like: ' . $amount_to_like . ', $activities[$users_events_per_account[$account_id][$username][0]]->user_id: ' . $activities[$users_events_per_account[$account_id][$username][0]]->user_id);
      }
      
      // If it's a Like activity (not a New Follower),
      // Try to find out if there were already liked or planned to be liked medias of this user for the past X hours
      // If yes, we won't like new his medias for this activity, and mark all his current activity
      $recently_liked_media_id = NULL;
      $current_user_event_type = 2;    
      foreach ($users_events_per_account[$account_id][$username] as $event_aid) {
        if ($activities[$aid]->activity_type == 3) {
          $current_user_event_type = 3;
          break;
        }
      }
      if ($current_user_event_type != 3) {
        $query = db_select('a4s_insta_clicks_by_tag', 't')
          ->fields('t', array('cid'));
        $query->condition('t.account_id', $account_id);
        $query->condition('t.media_owner_id', $activities[$users_events_per_account[$account_id][$username][0]]->user_id);
        
        //$db_or = db_or()->isNull('t.timestamp_liked')->condition('t.timestamp_liked', REQUEST_TIME - 60*60*$hours_to_skip_liking, '>');
        $db_or = db_or()->isNull('t.liked')->condition('t.timestamp_liked', REQUEST_TIME - 60*60*$hours_to_skip_liking, '>');
        
        $query->condition($db_or);
        $recently_liked_media_id = $query->execute()->fetchField();
      }
      if ($recently_liked_media_id) {
        db_update('a4s_insta_user_activities')
          ->fields(array('activity_local_status' => 2)) // 2 - ignored
          ->condition('aid', $users_events_per_account[$account_id][$username], 'IN')
          ->execute();
        
        watchdog('a4s insta activities like-back', "Warning: Ignored adding medias to like from account_id [$account_id], a user [$username] already has been liked for the last $hours_to_skip_liking hours");
        if ($dpm) {
          dpm('a4s insta activities like-back', "Warning: Ignored adding medias to like from account_id [$account_id], a user [$username] already has been liked for the last $hours_to_skip_liking hours");
        }
      }
      else if($added_medias_amount = a4s_instagram_set_user_medias_to_like($account_id, $username, $activities[$users_events_per_account[$account_id][$username][0]]->user_id, 'back-like', $amount_to_like, $dpm)) {
        $events_to_set_processed = array_merge($events_to_set_processed, $users_events_per_account[$account_id][$username]);
        $users_to_like_success[$account_id][$username] = $added_medias_amount;
      }
      else {
        
        db_update('a4s_insta_user_activities')
          ->fields(array('failed' => $activities[$users_events_per_account[$account_id][$username][0]]->failed + 1))
          //->condition('aid', $users_events_per_account[$account_id][$username][0])
          ->condition('aid', $users_events_per_account[$account_id][$username], 'IN')
          ->execute();
        
        watchdog('a4s insta activities like-back', "Warning: no medias added for account_id: $account_id, username: $username");
        if ($dpm) {
          dpm('a4s insta activities like-back', "Warning: no medias added for account_id: $account_id, username: $username");
        }
      }
    }
  }
  
  if (!empty($events_to_set_processed)) {
    // Set processed events as processed in DB
    db_update('a4s_insta_user_activities')
        ->fields(array('activity_local_status' => 1))
        ->condition('aid', $events_to_set_processed, 'IN')
        ->execute();
    watchdog('a4s insta activities like-back', 'Prepared back-like medias for ==> <pre>'. print_r($users_to_like, TRUE) . '</pre>');
  }
  else {
    watchdog('a4s insta activities like-back', '??? No back-like medias prepared for ==> <pre>'. print_r($users_to_like, TRUE) . '</pre>');
  }
  
  if ($dpm) {
    dpm($activities, '$activities');
    dpm($users_events_per_account, '$users_events_per_account');
    dpm($users_to_like, '$users_to_like');
    dpm($events_to_set_processed, '$events_to_set_processed');
    dpm($users_to_like_success, '$users_to_like_success');
    
    return 'Finished Activities back-likes medias preparing...';
  }
  drupal_json_output(array('Back-likes for new activities: ' => array('$users_to_like_success (Empty means Problems)' => $users_to_like_success, '$users_to_like (processed users)' => $users_to_like, '$events_to_set_processed' => $events_to_set_processed)));
}

/**
 * 
 * @return string
 */
function a4s_instagram_autoFollowing_history_page() {
  
  $args = arg();
  if (empty($args[2]) || !$account_id = a4s_instagram_get_local_account_id_by_username($args[2])) {
    return 'Wrong request...';
  }
  
  $last_hours = !empty($args[3]) ? $args[3] : variable_get('a4s_insta_history_period_hours_default', 12);
  $out = '';
  $changed = '';
  
  $query = db_select('a4s_insta_auto_following', 'f')
    ->fields('f', array())
    ->condition('f.account_id', $account_id);
    //->condition('a.timestamp', REQUEST_TIME - (60*60*$last_hours), '>') // for last 1 hour
  
  
  $query->leftJoin('a4s_insta_followers', 'w', 'w.remote_id = f.remote_id');
  $query->fields('w', array('is_following_now'));  

  if ($last_hours == 'all') {
    // Select ALL rows
  }
  elseif ($last_hours == 'all-following') {
    $query->condition('f.status', 1)->isNull('f.timestamp_ended');
  }
  elseif ($last_hours == 'all-followed') {
    $query->condition('w.is_following_now', 1);
  }
  else {
    $threshold_timestamp = REQUEST_TIME - (60*60*$last_hours);
    $db_or = db_or()->condition('f.timestamp_started', $threshold_timestamp, '>')->condition('f.timestamp_ended', $threshold_timestamp, '>')->condition('f.timestamp_added', $threshold_timestamp, '>');  
    $query->condition($db_or);
    if (variable_get('a4s_insta_autofollow_history_show_only_valid', TRUE)) {
      $db_or = db_or()->condition('f.status', 1)->isNull('f.status');
      $query->condition($db_or);
    }
  }
  
  $query->leftJoin('a4s_insta_users_extra_data', 'e', 'e.remote_id = f.remote_id');
  $query->fields('e', array('username', 'fullname', 'followed_by_amount', 'following_amount', 'posts_amount'));  
  $query->addField('e', 'thumbnail', 'user_thumbnail');  
  
  $query->leftJoin('a4s_insta_clicks_by_tag', 'm', 'm.cid = f.local_media_cid');
  $query->addField('m', 'caption', 'media_caption');
  $query->addField('m', 'shortcode', 'media_shortcode');
  $query->addField('m', 'thumbnail', 'media_thumbnail');
  
  $query->orderBy('f.timestamp_added', 'desc');
  $query->orderBy('f.timestamp_started', 'desc');
  $query->orderBy('f.timestamp_ended', 'desc');
  $followed_or_not = $query->execute()->fetchAllAssoc('fid');
  
  $counts = array(
    'Planned' => 0,
    'Following' => 0,
    'Unfollowed' => 0,
    'Skipped' => 0,
  );
  if (!empty($followed_or_not)) {
    foreach ($followed_or_not as $fid => $user) {
      
      $user_extra_data = a4s_instagram_get_user_statistics__relatedToRequestedAccount($user->username, $user->remote_id, $account_username = NULL, $account_id);
      $followed_or_not[$fid]->user_extra_data = $user_extra_data;
      
      if ($user->timestamp_ended) {
        $status_str = '<span style="color:gray;">Unfollowed</span>';
        $counts['Unfollowed']++;
      }
      elseif ($user->timestamp_started) {
        $status_str = '<span style="color:green;">Following</span>';
        $counts['Following']++;
      }
      elseif (!$user->status) {
        $status_str = '<span>Planned</span>';
        $counts['Planned']++;
      }
      else {
        $status_str = a4s_instagram_autoFollowing_statusMapping(NULL, $user->status);
        $status_str = '<span style="color:red;">' . ($status_str ? $status_str : 'N/A') . '</span>';
        $counts['Skipped']++;
      }
      
      $changed .= '<div class="activity" style="float:left; width:140px; height:520px; margin-right:5px; margin-bottom:30px;">'
              . '<div class="activity-date" style="margin-bottom:10px;">Status: ' . $status_str . '</div>'
              . '<div class="activity-date" style="margin-bottom:10px;">Added: ' . (!$user->timestamp_added ? 'N/A' : date('d/m/Y H:i', $user->timestamp_added)) . '</div>'
              . '<div class="activity-date" style="margin-bottom:10px;">Started: ' . (!$user->timestamp_started ? 'N/A' : date('d/m/Y H:i', $user->timestamp_started)) . '</div>'
              . '<div class="activity-date" style="margin-bottom:10px;">Ended: ' . (!$user->timestamp_ended ? 'N/A' : date('d/m/Y H:i', $user->timestamp_ended)) . '</div>'
          
              . ($user->username 
                  ? 
                  '<div class="user-title" style="height:50px;"><a href="https://instagram.com/' . $user->username . '">[' . $user->username . '] ' . utf8_decode($user->fullname) . '</a></div>'
                  :
                  '<div class="user-title" style="height:50px;"><a href="https://instagram.com/p/' . $user->media_shortcode . '">[Media: ' . utf8_decode($user->media_caption) . '] ' . '</a></div>'
               )
              . (
                  $user->user_thumbnail 
                   ? 
                  '<div class="user-img"><a href="https://instagram.com/' . $user->username . '"><img width="130px" src="' . $user->user_thumbnail . '"></a></div>'
                  :
                  '<div class="user-img"><a href="https://instagram.com/' . $user->username . '"><img width="70px" src="' . $user->media_thumbnail . '"></a></div>'
                  )
                  . '<div class="user-item" style="margin-top:5px;">Followers: ' . ($user->followed_by_amount ? $user->followed_by_amount : 'N/A' ). '</div>'
                  . '<div class="user-item">Following: ' . ($user->following_amount ? $user->following_amount : 'N/A') . '</div>'
                  . '<div class="user-item">Posts: ' . ($user->posts_amount ? $user->posts_amount : 'N/A') . '</div>'
                  
                  . '<div class="user-item">Your follower: ' . ($user->is_following_now ? '<span style="color:white;background:green;">Yes' : '<span style="color:red;">' . (!empty($user_extra_data['follower']) && !$user_extra_data['follower']->is_following_now ? 'Not anymore' : 'No') . '</span>') . (!empty($user_extra_data['repeating_following']) ? '<span title="' . print_r($user_extra_data['repeating_following'], TRUE) . '"  style="background:yellow; float:right; margin-right:10px; padding:0 3px; cursor:help;">R</span>' : '') . '</div>'
                  . '<div class="user-item">You follow him: ' . (!empty($user_extra_data['follower']) ? ($user_extra_data['follower']->followed_back ? 'Yes' : 'No') : 'N/A') . '</div>'
                  . '<div class="user-item">Auto liked by me: ' . count($user_extra_data['auto_liked_medias']) . '</div>'
          
                  //. '<div class="activity-type" style="margin-top:20px; ' . ($activity->activity_type == 3 ? 'background:green; color:white;' : 'color:green;') . '">' . $activity_types[$activity->activity_type] . '</div>'
                  
            . '</div>';
    }
  }
  //dpm($followed_or_not, '$followed_or_not');
  $short_report = '';
  foreach ($counts as $key => $value) {
    if ($value) {
      $short_report .= ($short_report ? ', ' : '') . $key . ': ' . $value;
    }
  }
  $out .= '<div>' . $short_report . '</div><br/><br/>';
  $out .= $changed;
      
  return "<h1 class='page-header' style='letter-spacing:3px;'>Auto following/unfollowing for the last $last_hours hours:</h1><br/>$out";
}

/**
 * Helper temporary function for copying extra user data from a table a4s_insta_followers to a a4s_insta_users_extra_data
 */
function _a4s_instagram_copyUserExtraData_from_between_tables() {
  
  $query = db_select('a4s_insta_followers', 'f')->fields('f', array());
  $followers = $query->execute()->fetchAllAssoc('fid');
  
  $existing_extra_data_GOOD = array();
  $existing_extra_data_BAD = array();
  $not_existing_extra_data = array();
  foreach ($followers as $follower) {
    $extra_data = db_select('a4s_insta_users_extra_data', 'd')
      ->fields('d', array())
      ->condition('d.remote_id', $follower->remote_id)
      ->execute()
      ->fetchObject();
    
    $new_user_extra_data = array(
      'username' => $follower->username,
      'fullname' => $follower->full_name,
      'thumbnail' => $follower->thumbnail,
    );
    if (!empty($extra_data)) {
      if (empty($extra_data->username) || empty($extra_data->fullname) || empty($extra_data->thumbnail)) {
        $existing_extra_data_BAD[$extra_data->username] = $extra_data;
        
        db_update('a4s_insta_users_extra_data')->fields($new_user_extra_data)->condition('eid', $extra_data->eid)->execute();
      }
      else {
        $existing_extra_data_GOOD[$extra_data->username] = $extra_data;
      }
      
    }
    else {
      $not_existing_extra_data[$follower->username] = $follower;
      $new_user_extra_data['remote_id'] = $follower->remote_id;
      $new_user_extra_data['timestamp_added'] = REQUEST_TIME;
      $eid = db_insert('a4s_insta_users_extra_data')->fields($new_user_extra_data)->execute();
    }
    break;
  }
  dpm($existing_extra_data_GOOD, '$existing_extra_data_GOOD');
  dpm($existing_extra_data_BAD, '$existing_extra_data_BAD');
  dpm($not_existing_extra_data, '$not_existing_extra_data');
}

/**
 * 
 * @param type $data_type
 *  following, followers
 * @param type $remote_username
 * @param type $pages_count
 * @param type $end_cursor
 * @param type $items_per_query
 * @return boolean
 */
function a4s_insta_get_remoteUser_data($data_type, $remote_user_id = NULL, $remote_username = NULL, $pages_count = NULL, &$end_cursor = NULL, $items_per_query = 10) {
  
  // The data will be requested by this user being logged in
  $own_account = 'all4senses';
  
  if (!$remote_user_id) {
    /*
    $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
    if (empty($behat_insta_cookies['https://instagram.com'][$own_account]['ds_user_id'])) {
      return FALSE;
    }
    $behat_insta_cookies_user = $behat_insta_cookies['https://instagram.com'][$own_account];
    $user_profile = a4s_insta_getDataSingle__fromRaw('user/profile', $remote_username, $max_id = NULL);
    */
    $user_profile = a4s_insta_get_userProfile($remote_username);
    $remote_user_id = $user_profile['id'];
  }
  $data = a4s_insta_queryGraphql_multiple($data_type, $own_account, $pages_count, $end_cursor, $items_per_query, $remote_user_id);
  return $data;
}

/**
 * 
 * @param type $remote_username
 * @return boolean
 */
function a4s_insta_get_userProfile($remote_username) {
  // The data will be requested by this user being logged in
  $own_account = 'all4senses';
  
  $behat_insta_cookies = variable_get('a4s_behat_insta_cookies', array());
  if (empty($behat_insta_cookies['https://instagram.com'][$own_account]['ds_user_id'])) {
    return FALSE;
  }
  $behat_insta_cookies_user = $behat_insta_cookies['https://instagram.com'][$own_account];

  $user_profile = a4s_insta_getDataSingle__fromRaw('user/profile', $remote_username, $max_id = NULL);
  return $user_profile;
}
/**
 * 
 * @param int $pages_count
 * @param int $items_per_query
 * @return type
 */
function a4s_insta_get_remoteUsers_followers_callback($pages_count = 2, $items_per_query = 40, $dpm = FALSE) {
  
  if(!$all_accounts = a4s_instagram_get_accounts_to_process('active')) {
    
    $processing_results = 'No active own users set for fetching followers from remote accounts. Skipping processing.';
    watchdog('a4s remote users followers', "ok: results ==> $processing_results", array(), WATCHDOG_INFO);
    if ($dpm) {
      dpm($processing_results);
    }
    drupal_json_output(array('status' => 'ok', 'results' => $processing_results));
    drupal_exit();
  }

  $processing_results = array();
  foreach ($all_accounts as $account) {
    if (!$like_remote_accounts_followers = variable_get('a4s_like_remote_accounts_followers__' . $account, NULL)) {
      if ($dpm) {
        dpm("Skipped remote users followers for $account, because it is turned off in settings");
      }
      $processing_results['warning']['own accounts'][$account]['remote accounts']['___warning'] = 'Remote users followers fetching/liking is turned off';
      continue;
    }
    $remote_accounts = variable_get('a4s_remote_accounts_to_get_folowers__' . $account, NULL);
    $remote_accounts = explode(',', $remote_accounts);
    foreach ($remote_accounts as $remote_account) {
      $remote_account = trim($remote_account);
      $remote_account_data = db_select('a4s_insta_remote_users', 'r')
        ->fields('r', array())
        ->condition('r.username', $remote_account)
        ->execute()
        ->fetchObject();
      
      if ($remote_account_data) {
        $remote_account_data = (array) $remote_account_data;
        $remote_account_data['fullname'] = utf8_decode($remote_account_data['fullname']);
        $remote_account_data['biography'] = utf8_decode($remote_account_data['biography']);
        if ($dpm) {
          dpm($remote_account_data, '$remote_account_data from DB');
        }
      }
      else {
        if ($dpm) {
          dpm('Get new $remote_account_data from Instagram...');
        }
        if (!$remote_account_profile = a4s_insta_getDataSingle__fromRaw('user/profile', $remote_account)) {
          $message = "User [$remote_account]: Error while retrieving a remote account profile data";
          watchdog('a4s remote users followers', $message, array(), WATCHDOG_WARNING);
          if ($dpm) {
            dpm($message);
          }
          $processing_results['errors']['own accounts'][$account]['remote accounts'][$remote_account]['___error'] = 'Error while retrieving a remote account profile data';
          continue;
        }
        // Write a new remote user profile to DB
        $remote_account_data = array(
          'remote_id' => $remote_account_profile['id'],
          'username' => $remote_account_profile['username'],
          'fullname' => utf8_encode($remote_account_profile['full_name']),
          //'fullname' => $remote_account_profile['full_name'],
          'thumbnail' => $remote_account_profile['profile_pic_url'], 
          'biography' => utf8_encode($remote_account_profile['biography']),
          //'biography' => $remote_account_profile['biography'],
          'followed_by_amount' => $remote_account_profile['edge_followed_by']['count'],
          'following_amount' => $remote_account_profile['edge_follow']['count'],
          'posts_amount' => $remote_account_profile['edge_owner_to_timeline_media']['count'], 
          'extra_data' => NULL,
          'user_created' => NULL,
          'timestamp' => REQUEST_TIME,
        );
        $remote_account_data['uid'] = db_insert('a4s_insta_remote_users')->fields($remote_account_data)->execute();
        if ($dpm) {
          dpm($remote_account_data, '$remote_account_data new');
        }
        if (empty($remote_account_data['uid'])) {
          watchdog('a4s remote users followers', "Error while adding a remote user [$remote_account] to DB", array(), WATCHDOG_ERROR);
          $processing_results['errors']['own accounts'][$account]['remote accounts'][$remote_account]['___error'] = 'Error while adding a remote user to DB';
          continue;
        }
      }
      
      $total_fetched_per_remote_account = NULL;
      $total_added_before_remote_account = NULL;
      
      $remote_account_extra_data = !empty($remote_account_data['extra_data']) ? json_decode($remote_account_data['extra_data'], TRUE) : array();
      
      if ($dpm) {
        dpm($remote_account_extra_data, '$remote_account_extra_data');
      }
      
      $remote_account_extra_data['followers']['total_fetched'] = empty($remote_account_extra_data['followers']['total_fetched']) ? 0 : $remote_account_extra_data['followers']['total_fetched'];
      
      if (!empty($remote_account_extra_data['followers']['finished_fetching_followers'])) {
        if ($dpm) {
          dpm("Finished feching followers for $remote_account. Skipped.");
        }
        $processing_results['warnings']['own accounts'][$account]['remote accounts'][$remote_account]['followers']['___total_fetched'] = $remote_account_extra_data['followers']['total_fetched'];
        $processing_results['warnings']['own accounts'][$account]['remote accounts'][$remote_account]['followers']['___warning'] = 'Finished feching followers. Skipped.';
        continue;
      }
      
      $end_cursor = $previous_end_cursor = !empty($remote_account_extra_data['followers']['end_cursor']) ? $remote_account_extra_data['followers']['end_cursor'] : NULL;
      if ($dpm) {
        dpm($end_cursor, '$end_cursor before');
      }
      
      $remote_user_followers = a4s_insta_get_remoteUser_data($data_type = 'followers', $remote_account_data['remote_id'], $remote_account, $pages_count, $end_cursor, $items_per_query);
      if ($remote_user_followers === FALSE) {
        $message = "Error while fetching followers for a remote user [$remote_account] from Instagram";
        watchdog('a4s remote users followers', $message, array(), WATCHDOG_WARNING);
        if ($dpm) {
          dpm($message);
        }
        $processing_results['errors']['own accounts'][$account]['remote accounts'][$remote_account]['___error'] = 'Error while fetching followers from Instagram';
        continue;
      }
      if ($dpm) {
        dpm($end_cursor, '$end_cursor after');
        dpm($remote_user_followers, '$remote_user_followers');
      }
      if (!empty($remote_user_followers)) {
        $followers_added_before = array();
        $new_followers = array();
        foreach ($remote_user_followers as $follower) {
          $follower = $follower['node'];
          // Check if this follower of this remote user is not already in our DB
          $follower_added_before = db_select('a4s_insta_remote_users_followers', 'f')
            ->fields('f', array('username'))
            ->condition('f.user_uid_local', $remote_account_data['uid'])->condition('f.follower_id', $follower['id'])
            ->execute()->fetchField();
          if ($follower_added_before) {
            $followers_added_before[] = $follower_added_before;
            $processing_results['warnings']['own accounts'][$account]['remote accounts'][$remote_account]['followers'][$follower_added_before] = 'Already added before. Skipped.';
            continue;
          }
          
          // Write a new follower of this remote user to DB
          $remote_account_follower_data = array(
            'user_uid_local' => $remote_account_data['uid'],
            'follower_id' => $follower['id'],
            'username' => $follower['username'],
            'fullname' => utf8_encode($follower['full_name']),
            //'fullname' => $follower['full_name'],
            'thumbnail' => $follower['profile_pic_url'],
            'liked_by_our_accounts' => NULL,
            'followed_by_our_accounts' => NULL,
            'timestamp_added' => REQUEST_TIME,
            'timestamp_updated' => REQUEST_TIME,
          );
          $fid = db_insert('a4s_insta_remote_users_followers')->fields($remote_account_follower_data)->execute();
          if ($fid) {
            $new_followers[] = $follower['username'];
          }
          //dpm($remote_account_follower_data, '$remote_account_follower_data');
        }
        
        if (!empty($followers_added_before)) {
          $total_added_before_remote_account = count($followers_added_before);
          if ($dpm) {
            dpm($followers_added_before, "FOUND ADDED BEFORE, followers_added_before for $remote_account");
          }
          // Collect the total amount of followers to report
          $processing_results['warnings']['own accounts'][$account]['remote accounts'][$remote_account]['followers']['___added_before_skipped'] = $total_added_before_remote_account;
        }
        
        if (!empty($new_followers)) {
          $total_fetched_per_remote_account = count($new_followers);
          if ($dpm) {
            dpm($new_followers, "NEW FETCHED ADDED TO DB, new_followers for $remote_account");
          }
          // Collect the total amount of followers to report
          $processing_results['success']['own accounts'][$account]['remote accounts'][$remote_account]['followers']['___added_this_time'] = $total_fetched_per_remote_account;
        }
        
      }
      
      $processing_results['success']['own accounts'][$account]['remote accounts'][$remote_account]['end_cursor'] = array('current' => $end_cursor, 'previous' => $previous_end_cursor);
          
      if ($previous_end_cursor != $end_cursor) {
        $remote_account_extra_data['followers']['end_cursor'] = $end_cursor;
        if (!$end_cursor) {
          $remote_account_extra_data['followers']['finished_fetching_followers'] = TRUE;
          $remote_account_extra_data['followers']['the_last_end_cursor'] = $previous_end_cursor;
          
          $processing_results['success']['own accounts'][$account]['remote accounts'][$remote_account]['__finished_fetching'] = TRUE;
        }
      }
      
      if ($total_fetched_per_remote_account) {
        $remote_account_extra_data['followers']['fetched_last_time'] = $total_fetched_per_remote_account;
        $remote_account_extra_data['followers']['total_fetched'] += $total_fetched_per_remote_account;
      }
      
      $processing_results['success']['own accounts'][$account]['remote accounts'][$remote_account]['followers']['___total_fetched'] = $remote_account_extra_data['followers']['total_fetched'];
      
      if ($previous_end_cursor != $end_cursor || $total_fetched_per_remote_account) {
        
        // Update the remote user data, tocontinue getting its data next time it from the previous point
        db_update('a4s_insta_remote_users')
          ->fields(array(
           'extra_data' => json_encode($remote_account_extra_data),
          ))
          ->condition('uid', $remote_account_data['uid'])
          ->execute();
      }
      
      
    }
    
                    
  }
  
  if (!empty($processing_results['errors'])) {
    $status = 'error';
    $watchdog_status = WATCHDOG_ERROR;
  }
  elseif (!empty($processing_results['warnings'])) {
    $status = 'warning';
    $watchdog_status = WATCHDOG_WARNING;
  }
  elseif (!empty($processing_results['success'])) {
    $status = 'success';
    $watchdog_status = WATCHDOG_DEBUG;
  }
  else {
    $status = 'ok';
    $watchdog_status = WATCHDOG_INFO;
  }
  watchdog('a4s remote users followers', "$status: results ==><pre>" . print_r($processing_results, TRUE) . '</pre>', array(), $watchdog_status);
  if ($dpm) {
    dpm($processing_results, "processing_results: $status");
  }
  drupal_json_output(array('status' => $status, 'results' => $processing_results));
}


/**
 * 
 * @param type $remote_accounts_per_own_user_to_process
 * @param type $followers_per_remote_user_to_process
 * @param type $medias_to_like_per_follower
 * @param type $dpm
 */
function a4s_insta_getAndPlan_remoteUserFollower_medias_to_like($remote_accounts_per_own_user_to_process = 3, $followers_per_remote_user_to_process = 2, $medias_to_like_per_follower = 3, $dpm = FALSE) {
  
  
  $remote_accounts_per_own_user_to_process = 3; 
  $followers_per_remote_user_to_process = 1; 
  $medias_to_like_per_follower = 2;
  
  
  $added = 0;
  
  if(!$all_accounts = a4s_instagram_get_accounts_to_process('active')) {
     $processing_results = 'No active own users set for fetching remote accounts followers medias to like to. Skipping processing.';
     watchdog('a4s remote users followers: get-n-plan medias', "ok: results ==> $processing_results", array(), WATCHDOG_INFO);
     if ($dpm) {
       dpm($processing_results);
     }
     drupal_json_output(array('status' => 'ok', 'results' => $processing_results));
     drupal_exit();
  }

  $followers_data = array();
  $processing_results = array();

  foreach ($all_accounts as $own_account) {

      if (!$like_remote_accounts_followers = variable_get('a4s_like_remote_accounts_followers__' . $own_account, NULL)) {
          if ($dpm) {
            dpm("Skipped remote users followers for $own_account, because it is turned off in settings");
          }
          $processing_results['warning']['own accounts'][$own_account]['remote accounts']['___warning'] = 'Remote users followers fetching/liking is turned off';
          continue;
      }

      $remote_accounts = variable_get('a4s_remote_accounts_to_get_folowers__' . $own_account, NULL);
      $remote_accounts = explode(',', $remote_accounts);
      if (empty($remote_accounts)) {
          if ($dpm) {
            dpm("Skipped remote users followers medias fetching for $own_account, because the list of remote accounts is empty in settings");
          }
          $processing_results['warning']['own accounts'][$own_account]['remote accounts']['___warning'] = 'Remote accounts list is empty';
          continue;
      }

      foreach ($remote_accounts as $key => $remote_account) {

          // Process only first $remote_accounts_per_own_user_to_process remote accounts per own user
          if ($remote_accounts_per_own_user_to_process-1 < $key) {
            continue;
          }
          $remote_account = trim($remote_account);

          // Get next $followers_per_remote_user_to_process followers to fetch medias from
          $query = db_select('a4s_insta_remote_users_followers', 'f')
                ->fields('f', array('fid', 'user_uid_local', 'follower_id', 'username'));
          $query->leftJoin('a4s_insta_remote_users', 'r', 'r.uid = f.user_uid_local');
          $query->fields('r', array( 'username'));
          $query->condition('r.username', $remote_account)
                ->isNull('f.liked_by_our_accounts')
                //->orderBy('fid')
                ->range(0, $followers_per_remote_user_to_process);
          $followers_data[$own_account][$remote_account] = $query->execute()->fetchAllAssoc('fid');

      } // End of foreach ($remote_accounts as $key => $remote_account) {

  } // End of foreach ($all_accounts as $account) {


  foreach ($followers_data as $own_account) {
    $account_id = a4s_instagram_get_local_account_id_by_username($own_account);
    foreach ($own_account as $remote_account) {
       foreach ($remote_account as $follower) {
         $added += a4s_instagram_set_user_medias_to_like($account_id, $follower->username, $follower->follower_id, $tag = 'remote-account-follower', $amount = $medias_to_like_per_follower, $dpm);
       }
    }
  }

  dpm($followers, '$followers');
  return $added;
}